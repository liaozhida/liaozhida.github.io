<!-- ---
layout:     post
title:      "单元测试"
date:       2018-09-21 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 代码质量
    - 测试
--- -->

## 理论篇


#### 单元测试的好处
- 对自己代码
- 对团队
- 良好的设计

#### rpc接口是否需要测试

RPC接口一般大家会忽略他的测试，觉得只要DAO层和业务层通过测试，验证了核心的业务流程就可以了，

- RPC的接口一般包含了数据校验加工和逻辑分发处理，如果因为上层的处理失败，下层的核心业务是正常的一样不能提供服务
- 保证返回给前端的数据结构符合要求


#### 应该为私有方法添加测试么？

新创建项目：
在成功的用了TDD或者测试驱动重构（Test-Driven Refactoring）以后，你的代码中就不会出现针对私有方法的测试。
如果你用TDD编写全新的代码，在没有测试之前是没有功能的。私有方法是到了重构那一步的最后才会出现。把代码转移到私有方法中的这个过程，已经被先前写过的测试覆盖到了。所以，如果你成功了用了TDD，代码中就不会出现针对私有方法的测试。

遗留项目：
如果你在改善遗留代码，你就该使用测试驱动重构。这样的话，可能会临时针对私有方法写一些测试。但是，随着测试覆盖率的增加，那些public方法的测试会覆盖到所有的路径，也包括了私有方法的调用。所以，你也不再需要测试私有方法。

临时私有方法测试采用映射的方式编写；

```
// DEMO 
Example example = new Example();
Method add = example.getClass().getDeclaredMethod("add", int.class, int.class);
add.setAccessible(true);
```

详情可以参考这篇文章：[Testing Private Methods with JUnit and SuiteRunner](https://www.artima.com/suiterunner/private.html) ， 要点如下：
- Don't test private methods.
- Give the methods package access.
- Use a nested test class.
- Use reflection.

---

You should instead test your public interface. If the methods that call your private methods are working as you expect, you then assume by extension that your private methods are working correctly.

[How do you unit test private methods?](https://softwareengineering.stackexchange.com/questions/100959/how-do-you-unit-test-private-methods)

单元测试：


代码的交付需要
- 单元测试
- 集成测试

#### 单元测试回滚

```
默认机制:  不 回滚
```


自动回滚
```
@Transactional
@TransactionConfiguration(defaultRollback=true)
```

AbstractTransactionalJUnit4SpringContextTests默认操作修改、新增、删除操作是事务自动回滚，避免出现脏数据，如果不需要回滚，可以添加@Rollback(false)注解即可。
```
extends AbstractTransactionalJUnit4SpringContextTests  
```


#### 单元覆盖率统计


[代码覆盖率浅谈](https://tech.youzan.com/code-coverage/)

jacoco
几个要点：
- 代码覆盖率统计是用来发现没有被测试覆盖的代码

1. 对Java字节码进行插桩，On-The-Fly和Offine两种方式。 
2. 执行测试用例，收集程序执行轨迹信息，将其dump到内存。 
3. 数据处理器结合程序执行轨迹信息和代码结构信息分析生成代码覆盖率报告。 
4. 将代码覆盖率报告图形化展示出来，如html、xml等文件格式。 



#### 几种Mock比较

[Mockito vs JMockit](https://stackoverflow.com/questions/4105592/comparison-between-mockito-vs-jmockit-why-is-mockito-voted-better-than-jmockit) 

[https://www.baeldung.com/mockito-vs-easymock-vs-jmockit](Mockito vs EasyMock vs JMockit)




#### 单元测试的几个特性

好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。
- A:Automatic(自动化)
- I:Independent(独立性) 
- R:Repeatable(可重复)

SUT：System Under Test或Software Under Test的簡寫，代表待測程式。如果是單元測試，SUT就是一個function或method。
DOC：SUT中的依赖组件，一般用测试桩(Mock)代替




###### 是否要对私有方法进行测试

应该为私有方法添加测试么？
我的答案是，在成功的用了TDD或者测试驱动重构（Test-Driven Refactoring）以后，你的代码中就不会出现针对私有方法的测试。

如果你用TDD编写全新的代码，在没有测试之前是没有功能的。私有方法是到了重构那一步的最后才会出现。把代码转移到私有方法中的这个过程，已经被先前写过的测试覆盖到了。所以，如果你成功了用了TDD，代码中就不会出现针对私有方法的测试。

如果你在改善遗留代码，你就该使用测试驱动重构。这样的话，可能会临时针对私有方法写一些测试。但是，随着测试覆盖率的增加，那些public方法的测试会覆盖到所有的路径，也包括了私有方法的调用。所以，你也不再需要测试私有方法。


什么场景会出现

测试接口，里面的接口返回是Mock的，接口测试成功，但是 核心的函数没有测试到，会将核心的函数抽离出来

```
interface Hello{
    public Response sayAPI(){
        //TODO other...
        Request request = private function();
        return RemoteService.invoke(request);
    }
}
```

单元测试: RemoteService 是一个Mock对象,单元测试只能测试 前面的业务代码是没有异常，但是不能测试 request的对象与预期一致的
```
when(request).thenReturn(XXX) ; 通过是否返回XXX来判断Request是否与预期一致 ; 因为request对象地址不一样，所以无法通过这种方式
```

```
Example example = new Example();
Method add = example.getClass().getDeclaredMethod("add", int.class, int.class);
add.setAccessible(true);
assertEquals(10, add.invoke(example, 2, 8));
```

---

[Testing Private Methods with JUnit and SuiteRunner](https://www.artima.com/suiterunner/private.html)

---

You should instead test your public interface. If the methods that call your private methods are working as you expect, you then assume by extension that your private methods are working correctly.

[How do you unit test private methods?](https://softwareengineering.stackexchange.com/questions/100959/how-do-you-unit-test-private-methods)



#### 打桩私有方法测试

```

class LuckyNumberGenerator {

    public int getLuckyNumber(String name) {

        saveIntoDatabase(name);

        if (name == null) {
            return getDefaultLuckyNumber();
        }

        return getComputedLuckyNumber(name.length());
    }

    private void saveIntoDatabase(String name) {
        // Save the name into the database
    }

    private int getDefaultLuckyNumber() {
        return 100;
    }

    private int getComputedLuckyNumber(int length) {
        return length < 5 ? 5 : 10000;
    }

}


```

```
@Test
public final void givenPrivateMethodWithArgumentAndReturn_whenUsingPowerMockito_thenCorrect() throws Exception {
    LuckyNumberGenerator mock = spy(new LuckyNumberGenerator());

    doReturn(1).when(mock, "getComputedLuckyNumber", ArgumentMatchers.anyInt());

    int result = mock.getLuckyNumber("Jack");

    assertEquals(1, result);
}
```

Mocking techniques should be applied to the external dependencies of the class and not to the class itself.

If mocking of private methods is essential for testing our classes, it usually indicates a bad design.

[Mocking of Private Methods Using PowerMock](https://www.baeldung.com/powermock-private-method)

#### 外部依赖


###### 对于数据库的依赖:

单元测试肯定是不能与实际数据库连接的，无论是本地开发数据库或者beta。所有对数据库操作的单元测试都需要是in memory。所以，你需要利用Dependency Injection的技术来提供一个in-memory database。

对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。
因为数据库里的数据都是有关联的，构造测试数据不是构造一两条记录那么简单

【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的， 或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。
反例:删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这 一行新增数据并不符合业务插入规则，导致测试结果异常。




###### 对于外部系统的依赖

- 使用Mock技术代替
- 打桩处理，类似 [swagger](https://swagger.io/) 这样的外部服务或者自己用NodeJs搭建一个简单的路由转发应用，定义好接口地址和返回的结果数据结构





按 《持续交付：发布可靠软件的系统方法》 里的说法，单元测试甚至不应该依赖数据库：因为访问数据库相对而言还是比较慢的。如果单测太慢，大家就不愿意等待单测通过才 push 代码，进而会影响到持续集成。

如果待测试的代码需要依赖外部系统，那上面的问题就更明显了：外部系统的访问比数据库更慢，而且因为是外部系统，不太可能因为单元测试就去外部系统上构造数据，回滚更是无从谈起。

由此看来，最好还是在单元测试中仅测试待测代码的逻辑，mock 这段代码的外部依赖。




## Mock 工具

- 外部的服务会导致在 单测环境下没有办法工作， 比如数据库和外部的系统
- 测试应该关注的是类的代码实现， 如果外部的类会直接的影响到这些被测试的类，那不是我们想要的结果

Mockito 和 PowerMock 都用于集成测试中，使用mock对象替代耦合的类，两者的不同在于 Mockito 适用于所有标准的场景， PowerMock 用于特殊的情况：比如Mock私有 & 静态的方法。

###### Mock & Spy

8. 在真实的对象上进行spy

 
spy的意思是你可以修改某个真实对象的某些方法的行为特征，而不改变他的基本行为特征，这种策略的使用跟AOP有点类似。下面举一个例子来说明：

 
```
List list = new LinkedList();  
List spy = spy(list);  
  
//optionally, you can stub out some methods:  
when(spy.size()).thenReturn(100);  
   
//using the spy calls <b>real</b> methods  
spy.add("one");  
spy.add("two");  
   
//prints "one" - the first element of a list  
System.out.println(spy.get(0));  
   
//size() method was stubbed - 100 is printed  
System.out.println(spy.size());  
   
//optionally, you can verify  
verify(spy).add("one");  
verify(spy).add("two");  
```
 
可以看到spy保留了list的大部分功能，只是将它的size方法改写了。不过spy在使用的时候有很多地方需要注意，一不小心就会导致问题，所以不到万不得已还是不要用spy。下面介绍两个spy的陷阱：


【1】有时我们无法使用when的方式来spy，此时我们就需要使用doReturn|Answer|Throw() 等方式来进行spy了：

 

```
List list = new LinkedList();  
List spy = spy(list);  
  
//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)  
when(spy.get(0)).thenReturn("foo");  
  
//You have to use doReturn() for stubbing  
doReturn("foo").when(spy).get(0);  
 比如我们使用when的时候实际已经调用了get(0)方法，这个时候将直接抛出异常，所以此时应该使用doReturn来进行spy    
```
---



【2】spy实际上是对对象做了一个拷贝，就像上面的，如果我们直接看list这个对象，它实际上只执行了这样一句话List list = new LinkedList();


#### Mockito

多次调用

---

when(mock.someMethod(anyString())).thenAnswer(new Answer() {  
    Object answer(InvocationOnMock invocation) {  
        Object[] args = invocation.getArguments();  
        Object mock = invocation.getMock();  
        return "called with arguments: " + args;  
    }  
});  
  
//Following prints "called with arguments: foo"  
System.out.println(mock.someMethod("foo"));  



when(mock.someMethod("some arg"))  
  .thenThrow(new RuntimeException())  
  .thenReturn("foo");  
  
//First call: throws runtime exception:  
mock.someMethod("some arg");  
  
//Second call: prints "foo"  
System.out.println(mock.someMethod("some arg"));  
  
//Any consecutive call: prints "foo" as well (last stubbing wins).   
System.out.println(mock.someMethod("some arg"));  


when(mock.someMethod("some arg"))  
  .thenReturn("one", "two", "three");  


---

doAnswer

```
@Test
public void testPLZAddressCombinationIncludingHostValue() {
 
    // 
    // Given
    //
    Customer customer = new Customer("204", "John Do", "224B Bakerstreet");
 
    doAnswer(new Answer<Customer>() {
        @Override
        public Customer answer(InvocationOnMock invocation) throws Throwable {
            Object originalArgument = (invocation.getArguments())[0];
            Customer param = (Customer) originalArgument;
            param.setHostValue("TestHostValue");
            return null;
        }
    }).when(hostService).expand(any(Customer.class));
 
    when(addressService.getPLZForCustomer(customer)).thenReturn(47891);
    doNothing().when(addressService).updateExternalSystems(customer);
 
    //
    // When
    //
    String address = customerService.getPLZAddressCombinationIncludingHostValue(customer, true);
 
    //
    // Then
    //
    Mockito.verify(addressService, times(1)).updateExternalSystems(any(Customer.class));
    assertThat(address, is("47891_224B Bakerstreet_TestHostValue"));
}
```



PS: verify 的用法是验证这个方式是否被调用过

###### void 方法

使用 doThrow()|doAnswer()|doNothing()|doReturn() 来 stub void方法

 


void方法也需要stub？呵呵，实际生活中我们应该只会用到doThrow来模拟这个void方法出错的情况吧，anyway，mockito提供了四个方法，发挥你的想象力吧:-)

Java代码  收藏代码
doThrow(new RuntimeException()).when(mockedList).clear();  
  
//following throws RuntimeException:  
mockedList.clear();  
  参见网页例子12。


#### PowerMock

为什么要用 PowerMock ？

[Mockito And Private Methods](https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods)
遗留系统


上面的例子已经能够覆盖绝大部分的场景，但是如果耦合的方法是静态的咋整？

PowerMockito 支持大部分Mockito 不支持的场景

比如：静态、私有、构造方法

PowerMockito 使用的是操纵字节的方式，所以他使用的是自己的 JUnit runner. 需要使用@PrepareForTest注释

```
@RunWith(PowerMockRunner.class)
@PrepareForTest({StaticService.class})
public class ItemServiceTest {
 
    @Mock
    private ItemRepository itemRepository;
 
    @InjectMocks
    private ItemService itemService;
 
    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
    }
 
    @Test
    public void readItemDescriptionWithoutIOException() throws IOException {
  
        String fileName = "DummyName";
 
        mockStatic(StaticService.class);
     
        String value = itemService.readItemDescription(fileName);
  
        verifyStatic(times(1));
        StaticService.readFile(fileName);
        assertThat(value, equalTo("Dummy"));
    }
}
```

PowerMock 大部分的写法和 Mockito 类似，因为 PowerMock 是扩展 Mockito 的 API 形成的

######  依赖


```
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.8.9</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4-rule</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito2</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-classloading-xstream</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
```

###### 用法

//通过PowerMock创建一个虚拟对象
InterfaceToMock mock = Powermockito.mock(InterfaceToMock.class)
//value为你想要让这个method返回的值
Powermockito.when(mock.method(Params…)).thenReturn(valueToReturn)
//如果这个方法返回值为空，则上面的写法会报错,可采用下面的写法
Powermockito.when(mock, “methodName”, Object… params).thenReturn(valueToReturn)
// 也可以采用下面的写法，和上面的一样的效果
Powermockito.doReturn(valueToReturn).when(mock, “methodName”, Object… params)
//这样写也行，适合返回值为void的方法
Powermockito.doReturn(valueToReturn).when(mock).methodName(Object… params)
//你也可以让方法抛异常
Powermockito.when(mock.method(Params..)).thenThrow(new OMSException(“oms”))
//你可以让方法每一次返回的结果都不一样,下面的例子第一次正常返回，第二次调用抛异常
Powermockito.when(mock.method(Params..)).thenReturn(valueToReturn).thenThrow(new OMSException(“some Exception”))
//如果方法返回值为void,不能用thenReturn,要用doThing()
Powermockito.doNothing().when(mock.method(Params…))


PowerMockito.when(vasWithdrawFacade,"queryAmountByCondition", any()).thenReturn(response);
when(vasWithdrawFacade.queryAmountByCondition(any())).thenReturn(response);


---


```
//PowerMockito.suppress(PowerMockito.method(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal",Long.class,BigDecimal.class));
IcbcNraBizServiceImpl spy = spy(new IcbcNraBizServiceImpl());
when(spy, method(IcbcNraBizService.class, "createNraUsdTransfer_internal")).withNoArguments().thenReturn("Good Morning %s %s");
PowerMockito.doNothing().when(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal",Long.class,BigDecimal.class);
PowerMockito.suppress(PowerMockito.method(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal"));


```



#### 特性

###### 静态的方法。

```
@RunWith(PowerMockRunner.class)
@PrepareForTest({StaticService.class})
public class ItemServiceTest {
 
    @Mock
    private ItemRepository itemRepository;
 
    @InjectMocks
    private ItemService itemService;
 
    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
    }
 
    @Test
    public void readItemDescriptionWithoutIOException() throws IOException {
 
        //
        // Given
        //
        String fileName = "DummyName";
 
        mockStatic(StaticService.class);
        when(StaticService.readFile(fileName)).thenReturn("Dummy");
 
        //
        // When
        //
        String value = itemService.readItemDescription(fileName);
 
        //
        // Then
        //
        verifyStatic(times(1));
        StaticService.readFile(fileName);
        assertThat(value, equalTo("Dummy"));
    }
}
```


###### 私有方法

```
class Demo{
    
    /*转账*/
    public void transfetAmount(){
        this.getBankInfo()
    }

    /*获取银行渠道信息*/
    private void getBankInfo(){
        ...
    }
}
```

这个场景中， getBankInfo 是一个私有方法，已经在线上经过长时间的验证，默认是没有问题的，对 transfetAmount 方法的单元测试，不需要再引入 `getBankInfo`的测试，简化测试的复杂度，可以对 私有方法 进行Mock

```
@RunWith(PowerMockRunner.class)
@PrepareForTest({ Demo.class })
public class DemoTest {

    @Autowried
    private Demo demo;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // 写法1
        PowerMockito.suppress(PowerMockito.method(Demo.class,"getBankInfo"));
        //
        PowerMockito.doNothing().when(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal");
    }

    @Test
    public void test_01() {
        try {
            demo.transfetAmount();
        }catch (Exception e){
            Assert.fail();
        }
    }
}
```

#### 注意事项

几个点

- 被Mock的类不要使用接口类，你测试的是类的实现逻辑是否正确，不是接口是否优雅；而且会提示你找不到方法抛出异常。


## 常见异常

**1:java.lang.NoSuchMethodError**
org.mockito.internal.handler.MockHandlerFactory.createMockHandler(Lorg/mockito/mock/MockCreationSettings;)Lorg/mockito/internal/InternalMockHandler;

```
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4</artifactId>
    <version>2.0.0-beta.5</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito2</artifactId>
    <version>2.0.0-beta.5</version>
    <scope>test</scope>
</dependency>
```



**2:Extension API internal error**org.powermock.api.extension.reporter.MockingFrameworkReporterFactoryImpl
```
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito-common</artifactId>     
    <version>1.6.5</version>
</dependency>
```


**3:javassist 包冲突问题**

把不需要的版本排除掉即可，推荐版本
```
<dependency>
  <groupId>org.javassist</groupId>
  <artifactId>javassist</artifactId>
  <version>3.21.0-GA</version>
</dependency>
```

## 参考网站

[单元测试框架PowerMock教程](https://www.ezlippi.com/blog/2017/08/powermock-introduction.html)

[Mockito And Private Methods](https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods)

[使用Mockito进行单元测试【2】—— stub 和 高级特性](http://qiuguo0205.iteye.com/blog/1456528)

[Android单元测试(三)：PowerMock框架的使用](https://juejin.im/entry/5a10fb786fb9a04522071756)

[TestNG使用介绍](https://www.jianshu.com/p/74816a200221)

[Mockito and Power Mockito – Cheatsheet](https://raseshmori.wordpress.com/2015/01/07/mockito-and-power-mockito-cheatsheet/)

[JUnit Testing using Mockito and PowerMock](https://blog.codecentric.de/en/2016/03/junit-testing-using-mockito-powermock/)

[单元测试覆盖率-JaCoCo](https://www.ibm.com/developerworks/cn/java/j-lo-jacoco/index.html)

[Mocks Aren't Stubs](https://martinfowler.com/articles/mocksArentStubs.html)