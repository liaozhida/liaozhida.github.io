
#### 使用哈希查找有两个步骤:
- 使用哈希函数将被查找的`键转换为数组的索引`。在理想的情况下，不同的键会被转换为不同的索引值，有些情况下我们需要处理多个键被哈希到同一个索引值的情况。
- 所以哈希查找的第二个步骤就是处理冲突:处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，后面会介绍拉链法和线性探测法。

#### 时间和空间

哈希表是一个在时间和空间上做出权衡的经典例子。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。
- 如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)
- 如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。


#### 哈希函数

###### 正整数

获取正整数哈希值最常用的方法是使用`除留余数法`。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。

###### 字符串

将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希

Horner计算字符串哈希值的方法，公式为:
`h = s[0] · 31L–1 + … + s[L – 3] · 312 + s[L – 2] · 311 + s[L – 1] · 310`

举个例子，比如要获取”call”的哈希值，`字符串c对应的unicode为99`，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 3045982 = 99·313 + 97·312 + 108·311 + 108·310 = 108 + 31· (108 + 31 · (97 + 31 · (99)))

如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈西值来节省时间，比如，可以 获取每8-9个字符来获取哈希值：但是，对于某些情况，不同的字符串会产生相同的哈希值

#### 避免哈希冲突

######  拉链法 (Separate chaining with linked lists)

一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的`键值对`

”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串,map.get("John Smith”") = "020-12345678"

该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表顺序找到相应的键。

###### 线性探测法

线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位解决碰撞冲突。

开放寻址法中最简单的是线性探测法：当碰撞发生时即`一个键的散列值被另外一个键占用时`，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：
- 命中，该位置的键和被查找的键相同
- 未命中，键为空
- 继续查找，该位置和键被查找的键不同。

线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。

###### 性能分析

我们可以看到，哈希表存储和查找数据的时候分为两步:
- 第一步为将键通过哈希函数映射为数组中的索引， 这个过程可以认为是只需要常数时间的。
- 第二步是，如果出现哈希值冲突，如何解决，前面介绍了拉链法和线性探测法下面就这两种方法进行讨论：
	- 对于拉链法，查找的效率在于链表的长度，一般的我们应该保证长度在M/8~M/2之间，如果链表的长度大于M/2，我们可以扩充链表长度。如果长度在0~M/8时，我们可以缩小链表。
	- 对于线性探测法，也是如此，但是`动态调整数组的大小`需要对所有的值`进行重新散列`并插入新的表中。

不管是拉链法还是散列法，这种动态调整链表或者数组的大小以提高查询效率的同时，还应该考虑动态改变链表或者数组大小的成本。散列表长度加倍的插入需要进行大量的探测， 这种均摊成本在很多时候需要考虑。


#### Hash碰撞攻击

哈希表攻击就是通过精心构造哈希函数，使得所有的键经过哈希函数后都映射到同一个或者几个索引上，将哈希表退化为了一个单链表，这样哈希表的各种操作，比如插入，查找都从O(1)退化到了链表的查找操作，这样就会消耗大量的CPU资源，导致系统无法响应，从而达到拒绝服务供给(Denial of Service, Dos)的目的。

在.NET中String的哈希值内部实现中，通过使用哈希值随机化来对这种问题进行了限制，通过`对碰撞次数设置阈值`，超过该阈值就对哈希函数进行随机化，这也是防止哈希表退化的一种做法。

#### 多线程处理之 Fail-Fast机制

我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。

这一策略在源码中的实现是: 在迭代方法中通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。

在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：注意到modCount声明为volatile，保证线程之间修改的可见性。



[浅谈算法和数据结构（11）：哈希表](http://blog.jobbole.com/79261/)

[HashMap 多线程处理之 Fail-Fast机制：](http://www.cnblogs.com/alexlo/archive/2013/03/14/2959233.html)
