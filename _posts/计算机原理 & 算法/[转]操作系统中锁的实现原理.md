在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。

通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。所谓的锁，说白了就是内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

为了弄明白锁的实现原理，我们首先看看如果OS不采用任何其他手段，什么情况下会导致上锁失败？假如我们把加锁过程用如下伪码表示：
1、read lock；
2、判断lock状态；
3、如果已经加锁，失败返回；
4、把锁状态设置为上锁；
5、返回成功。


###### 什么情况能够导致两个线程同时获取到锁呢？
1、中断：假设线程A执行完第一步，发生中断，中断返回后，OS调度线程B，线程B也来加锁并且加锁成功，这时OS调度线程A执行，线程从第二步开始执行，也加锁成功。
2、多核：两个核上的代码同时申请一个锁，两个核同时取出锁变量，同时判断说这个锁是空闲状态，然后有同时修改为上锁状态，同时返回成功。两个核同时获取到了锁

###### 先考虑单核场景：
1、既然只有中断才能把上锁过程打断，造成多线程操作失败。我先关中断不就得了，在加锁操作完成后再开中断。
2、上面这个手段太笨重了，能不能硬件做一种加锁的原子操作呢？能，大名鼎鼎的“test and set”指令就是做这个事情的。


###### 那么多核环境呢

关键点是两个核会并行操作内存，而且从操作内存这个调度来看“test and set”不是原子的，需要先读内存然后再写内存，如果我们保证这个内存操作是原子的，就能保证锁的正确性了。

确实，硬件提供了锁内存总线的机制，我们在锁内存总线的状态下执行test and set操作，就能保证同时只有一个核来test and set，从而避免了多核下发生的问题。

###### 总结
总结一下，在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制；OS基于这几个CPU硬件机制，就能够实现锁；再基于锁，就能够实现各种各样的同步机制（信号量、消息、Barrier等等等等）。所以要想理解OS的各种同步手段，首先需要理解本文介绍的内容，这时最原点的机制，所有的OS上层同步手段都基于此。


###### test-and-set-lock, TSL
在计算机科学中，检查并设置（test-and-set-lock, TSL）是一种不可中断的基本（原语）运算。它会写值到某个内存位置并传回其旧值。**在多程序可同时存取内存的情况下，如果一个程式正在执行检查并设置，在它执行完成前，其它的程式不可以执行检查并设置。**中央处理器可使用可自行实作此指令，或利用其它电子元件如双埠随机存取内存（Dual-ported RAM）所提供的检查并设置机制。



[操作系统中锁的实现原理](http://blog.csdn.net/u011244446/article/details/52571745)