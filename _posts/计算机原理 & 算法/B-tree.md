
###### 重点

**磁盘的读/写原理和效率:**
磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。读/写磁盘上某一指定数据需要下面2个步骤：1、定位查找 2、盘片旋转读取信息


访问某一具体信息，由3部分时间组成：
● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。
● 等待时间(latency time) Tl: 由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。
● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概`0.02us=2*10^(-8)`

- 磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。
- 而磁盘IO代价主要花费在**查找时间Ts上**。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。
- 所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构



#### B- 树 

B-树，即为B树。是为了磁盘或其它存储设备而设计的一种多叉平衡查找树（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）。

与红黑树很相似，但在降低磁盘I/0操作方面要更好一些。许多数据库系统都一般使用B树或者B树的各种变形结构,B树与红黑树最大的不同在于:**B树的结点可以有许多子女，从几个到几千个**。

**B树与红黑树**:与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。

**B树中的每个结点根据实际情况可以包含大量的关键字信息和分支，当然是不能超过磁盘块的大小**，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右

这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。

###### 示例：

下面，咱们来模拟下查找文件29的过程：
- 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】    
- 此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17<29<35，因此我们找到指针p2。
- 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】    
- 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26<29<30，因此我们找到指针p2。
- 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】    
- 此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。

分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个`有序表结构`，可以利用折半查找提高效率。至`于IO操作是影响整个B树查找效率的决定因素`。

###### 一棵m阶的B树特性：

- 树中每个结点最多含有m个孩子（m>=2）；
- 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；
- 若根结点不是叶子结点，则至少有2个孩子；
- 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)


- 所有键值分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 在关键字全集内做一次查找,性能逼近二分查找；

#### B+-tree

是应文件系统所需而产生的一种B-tree的变形树。一棵m阶的B+树和m阶的B树的异同点在于：
- 有n棵子树的结点中含有n-1 个关键字
- 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
- 所有的非终端结点可以看成是**索引**部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也**包含需要查找的**有效信息)


###### 为什么说 B+树 比 B树更适合实际应用中操作系统的文件索引和数据库索引？

1、B+tree的磁盘读写代价更低

- B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
- B+树更适合外部存储,由于内节点无 data 域(具体的关键字信息，内存地址),一个结点可以存储更多的内结点,每个节点能索引的范围更大更精确,也意味着 B+树单次磁盘IO的信息量大于B-树,I/O效率更高。


2、B+tree的查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
读者点评

3、数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时，并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于**范围的查询**是非常频繁的，而B树不支持这样的操作（或者说效率太低）

4、Mysql是一种关系型数据库，区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

#### .B*-tree
`B*-tree`是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B*树中非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示：


###### B+树的分裂：

当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，**而不会影响兄弟结点，所以它不需要指向兄弟的指针**。

###### `B*`树的分裂：

当一个结点满时，如果它的`下一个兄弟结点未满，那么将一部分数据移到兄弟结点中`，再在原结点插入关键字，`最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了`）；

如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。

所以，**`B*`树分配新结点的概率比B+树要低，空间`使用率`更高；**


#### 总结

###### 通过以上介绍，大致将B树，B+树，B*树总结如下：
- B树：有序数组 + 平衡多叉树；
- B+树：有序数组链表 + 平衡多叉树；
- `B*树`：一棵丰满的B+树。(空间使用率更高)

Bt的增删改和 2-3 树类似

在大规模数据存储的文件系统中，B~tree系列数据结构，起着很重要的作用，对于存储不同的数据，节点相关的信息也是有所不同。(这里假设每个物理块容纳3个索引，磁盘的I/O操作的基本单位是块（block),磁盘访问很费时，采用B+树有效的减少了访问磁盘的次数。）


###### 其他

走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见： 

B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。

比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，

B树就非常麻烦。**B树的好处**，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。

B树比如你的例子中查，17的话，一把就得到结果了，

有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。

另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”非常感谢。

mysql 底层存储是用B+树实现的，内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。



#### 参考网站

[由 B-/B+树看 MySQL索引结构](https://segmentfault.com/a/1190000004690721)

[从B树、B+树、`B*`树谈到R 树](http://blog.csdn.net/v_JULY_v/article/details/6530142)

[Bt的增删改和 2-3 树类似](为什么推荐InnoDB引擎使用自增主键？)

#### 重点

磁盘的步骤和优化点

B树为了降低高度， 将相关数据放在数据库

B+树 叶节点、范围查找、非叶节点节省空间

`B*`树 提高空间利用率， 兄弟指针

B树有点：  深度关键字、频率



