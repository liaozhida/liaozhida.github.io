
---
layout:     post
title:      "面试清单(3)-Java面向对象的特性.md"
subtitle:	""
date:       2010-10-23 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-road.jpg"
tags:
    - zчастный
---


面试清单(3)-Java面向对象的特性.md


#### 访问控制

访问控制修饰符			|同一个类 |	同一个包	| 不同包的子类	| 不同包的非子类
------------ | ------------- | -- ------- | ------------- | ------------
private(私有的)		| ✓	 | ✕	| ✕	| ✕
default(默认的)		| ✓	 | ✓	| ✕	| ✕
protected(受保护的)	| ✓	 | ✓	| ✓	| ✕
public(公共的)		| ✓	 | ✓	| ✓	| ✓


#### 多态

多态则是为了实现接口重用

覆盖，是指子类重新定义父类的虚函数的做法。

重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定）

重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”

一道面试题：两个线程，交替打印出1~100数字， 考察的不仅是达到目的，而且更优雅的代码去实现

```
public class PrinterDemo {

	private volatile static boolean flag = false;
	private volatile static int index = 1;
	private final static int MAX_VALUE = 100;

	public static void main(String[] args) {

		new Thread(new TaskA()).start();
		new Thread(new TaskB()).start();

	}

	static abstract class Task implements Runnable {

		abstract boolean interest();

		@Override
		public void run() {

			for (;;) {

				if (index > MAX_VALUE)
					break;

				if (interest()) {
					System.out.println(Thread.currentThread().getName() + "--" + index++);
					flag = !flag;
				}
			}
		}

	}

	static class TaskA extends Task {

		@Override
		boolean interest() {
			return flag;
		}

	}

	static class TaskB extends Task {

		@Override
		boolean interest() {
			return !flag;
		}

	}

}
```


#### 封装

封装可以隐藏实现细节，使得代码模块化

#### 继承

继承可以扩展已存在的代码模块（类）

###### 抽象类 和 接口

抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。以JDK中的GenericServlet为例：

接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。

###### 值类型与引用类型

因为Java分基本类型和对象类型两种，对于基本类型在调用函数的时候，Java都是传递值的，而对于对象类型，Java是传递引用的，也就是说函数内和函数外是同一个对象

[Java/数据类型](https://zh.wikibooks.org/zh-hans/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)

#### 设计原则

###### 单一职责 (Single-Resposibility Principle)。

"对一个类而言，应该仅有一个引起它变化的原因。"本原则是我们非常熟悉地"高内聚性原则"的引申。

同时，本原则还揭示了内聚性和耦合生，基本途径就是提高内聚性； 如果一个类承担的职责过多，那么这些职责就会相互依赖，一个职责的变化可能会影响另一个职责的履行。其实OOD（面向对象设计）的实质，就是合理地进行类的职责分配。

一个具体的例子：

想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。

保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，**如果有一个对于报表编辑流程的修改，打印功能的代码会因此不工作**，如果这两个功能存在于同一个类中的话。


###### 开放封闭 (Open-Closed principle)。

对修改封闭，对扩展开放。"软件实体应该是可以扩展的，但是不可修改。"本原则紧紧围绕变化展开，变化来临时，如果不必改动软件实体裁的源代码，就能扩充它的行为，那么这个软件实体设计就是满足开放封闭原则的。

一个类的实现只应该因错误而修改，新的或者改变的特性应该通过新建不同的类实现

例子：
- 如果说我们预测到某种变化，或者某种变化发生了，我们应当创建抽象类来隔离以后发生的同类变化。
- 如果要对类进行扩展，可以使用继承的方式，添加新的方法
- 改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程
- 多态开闭原则的定义倡导对抽象基类的继承 ，参照文首的线程例子

###### Liskov替换 (Liskov-Substituion Principle)。

派生类（子类）对象能够替换其基类（超类）对象被使用。

###### 依赖倒置原则(Dependecy-Inversion Principle)。

"抽象不应依赖于细节，细节应该依赖于抽象"

依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。

一个具体的例子：


```
//具体Jim人类
public class Jim {
    public void eat(Apple apple){
        System.out.println("Jim eat " + apple.getName());
    }
}
//具体苹果类
public class Apple {
    public String getName(){
        return "apple";
    }
}
public class Client {
    public static void main(String[] args) {
        Jim jim = new Jim();
        Apple apple = new Apple();
        jim.eat(apple);
    }
}
```

新增一个 bananer 类，就要修改Jim类。健壮和稳定无从谈起

根据依赖倒置原则，我们可以对上述代码做些修改，提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。


[依赖倒置原则](http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html)

###### 接口隔离 (Interface-Segregation Principle)。

"多个专用接口优于一个单一的通用接口。"本原则是单一职责原则用于接口设计的自然结果。一个接口应该保证，实现该接口的实例对象可以只呈现为单一的角色；这样，当某个客户程序的要求发生变化，而迫使接口发生改变时，影响到其他客户程序的可能生性小。

例子：JDK中的集合类，一般都会实现几个接口，每个接口有着不同的特性

 







