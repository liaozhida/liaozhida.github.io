---
layout:     post
title:      "面试清单(1)"
subtitle: ""
date:       2010-10-23 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-road.jpg"
tags:
    - zчастный
---

列了一些针对性的知识点，适用于针对大纲的一些知识点，然后遇到不懂的问题

适用场景：Java高级开发 （3~5年）

###### 职位名称：中间件技术部-Java资深开发工程师/专家-杭州，深圳

```
职位描述：中间件技术部是阿里巴巴集团生态系统的技术基石，为淘宝、天猫、聚划算、1688、B2B、AE、淘宝旅行、淘宝海外、零售O2O等业务群提供可靠、高效、易扩展的技术基础服务； 

1. 参与业务平台各业务线的设计，代码开发，系统稳定性开发，性能优化等相关工作 
2. 负责业务事业部中间件的产品的研发，维护和升级；
3. 理解业务方需求，参与架构的持续优化满足中间件服务快速发展的要求； 
4. 负责中间件产品方案落地项目的推进和跟踪，协调各方资源完成目标。

职位要求：
- 精通Java编程，有Java并发编程经验, 熟悉TCP/IP等通信协议，熟悉c/c++编程语言 
- 精通Java高性能网络服务器和数据库编程，在高并发，分布式通信，存储等相关领域有实际经验； 
- 了解主流的SQL/NOSQL数据库，对各数据库的优劣和适用场景有深入的理解，熟悉Hadoop体系架构和HBase数据库者优先； 
- 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题； 
- 在时间序列数据库领域有工作经验的优先，对于开源的openTSDB，druid，influxDB比较熟悉的优先； 
- 良好的团队协作能力，良好的沟通表达能力，具备优秀的文档能力，使用文字、图示清楚地表达架构意图，能够熟练编写各类技术文档。
```

###### 国际贸易服务技术部-0519深圳技术专场-外综服  
```
JAVA开发岗位要求： 
负责参与业务的系统架构及研发，对现有产品和系统进行改进和优化，实现面向未来的系统规划、设计和落地, 以架构角度把控系统的设计、落地以及运维，协调业务发展，统筹研发资源、把控系统实施节奏。 
1、有扎实的Java基础(熟悉io、多线程、集合等基础框架，熟悉分布式、缓存、消息、搜索等机制）； 
2、熟悉JAVAEE规范，深刻理解企业应用设计模式，熟悉应用容器，服务框架、消息中间件、数据中间件、企业集成、业务流程、业务规则等技术并有实践经验； 
3、对技术有热情，有团队合作精神，敢于担当，积极主动推动项目落地； 
4、具有算法背景或英语口语流利、有国际化背景和经验者优先； 
5、有财务、金融、税务、风控、商家运营、供应链等经验者优先考虑，具有较好的复杂业务场景的抽象能力。
```



自己的总结：这个阶段的程序员应该具备的素质，主要考察的点
- (1) Java常用类熟悉
- (2) Java的开源软件的了解（实际项目中使用到的）
- (3) Java面向对象的特性
- (4) 代码重构和代码风格的了解
- (5) 常用的设计模式配合实际工作场景
- (6) 良好的沟通能力和解决问题的思路（实际项目和常见的项目场景）
- (7) 有实际的大型项目的架构/管理经验，分析几个重要场景（面试官会通过一个场景分析你的想法和知识面）
- (8) Java内存模型 、 JVM相关知识，以及分析处理能力
- (9) 数据库的原理和知识面 (包括Nosql的使用场景和原理)
- (10) 其他语言的了解程度（Js Nodejs python） 考察较少 
- (11) Linux的使用经验（考察较少）
- (12) 项目管理（经验 过往经历等） 考察较少
- (13) HTTP相关原理和知识面 考察较少
- (14) 计算机原理和算法等  考察较少

 
 
 
(1) Java常用类熟悉

常用类包括几种
- 容器类
- 并发编程
- 文件处理/网络
- 反射（较少考察）



## 容器类

系统性的请查看 《Java容器类》系列文章 或者 《thinking in Java》结合**源码**学习

以下为零散的知识点：

###### hashMap 的1.8 改进

从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的

HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。 

key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。

使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。

## 并发编程

系统性的请查看 并发编程 系列文章 或者 通读《JAVA并发编程实战》结合常用多线程工具类源码学习

以下为零散的知识点：

######  Synchronized  和 Lock的区别

-  Synchronized  是JVM级别自带的机制， Lock 是代码级别的
-  Synchronized  关键字具备自然的语言级支持，这可能意味着 JIT 可能以某种方式优化同步块
- 一般认为 Synchronized 关键字的实现是源自于像信号量之类的线程同步机制，涉及到线程运行状态的切换，在高并发状态下，CPU消耗过多的时间在线程的调度上，从而造成了性能的极大浪费。 
- lock实现原理则是依赖于硬件，现代处理器都支持CAS指令，所谓CAS指令简单的来说 Compare And Set ，CPU循环执行指令直到得到所期望的结果
- 当JDK版本高于1.6的时候， Synchronized 已经被做了CAS的优化：具体是这样的，当执行到  Synchronized  代码块时，先对对象头的锁标志位用lock cmpxchg的方式设置成“锁住“状态，释放锁时，在用lock cmpxchg的方式修改对象头的锁标志位为”释放“状态，写操作都立刻写回主内存。JVM会进一步对  Synchronized  时CAS失败的那些线程进行阻塞操作(调用操作系统的信号量)(此段来摘自别处)。也就是先CAS操作，不行的话继而阻塞线程。

Lock的优势:

- 变得非结构化——比如，不会受块或方法的限制，允许你跨多个方法持有锁。
- 等待锁超时
- 配置失败策略
- 提供非公平锁
- 可中断
- 更丰富的加锁形式 读写锁等


###### 项目用的 多线程/容器类

消费者监听器 -> 消息入队列 -> 队列限额  |-> worker取消息处理 -> 处理完成判断队列数量 -> 还有元素继续取出来处理 (类似 threadpool 模式) -> 没有元素读取文件序列化 -> 还是没有就退出 
                                |-> 将超限额的消息序列化写入文件

###### 线程池的实现

ThreadPoolExecutor

```
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

```


- corePoolSize the number of threads to keep in the pool, even if they are idle
- maximumPoolSize the maximum number of threads to allow in the pool
- keepAliveTime ， 比corePoolSize多出来的线程空闲多久之后关闭


public ThreadPoolExecutor(int corePoolSize,
                        int maximumPoolSize,
                        long keepAliveTime,
                        TimeUnit unit,
                        BlockingQueue<Runnable> workQueue) {
  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue)
  

```

###### 线程 sleep  和 wait

- 首先，要记住这个差别，“sleep 是Thread类的方法,wait是Object类中定义的方法”。

- Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁

- 可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep是不会影响锁的相关行为。

- Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。

- 区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。

###### 使用同步容器类就安全了吗

- 同步容器类，如果不是复合操作依然会发生竞态条件
- 过度使用锁，会出现死锁的问题



###### 分析线程池的实现原理和线程的调度过程

参考文章：[JUC系列(3)-ThreadPoolExecutor-源码解析](http://www.paraller.com/2016/05/22/JUC%E7%B3%BB%E5%88%97(3)-ThreadPoolExecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)

实现原理：
- 为了避免线程创建的开销和提高响应性。
- 创建一个 ExecutorService,指定了初始的线程数量和队列
- LinkedBlockingQueue不传构造参数，默认的队列容量为:Integer.MAX_VALUE,也就是无界阻塞队列
- 当提交一个任务的时候，会判断线程数量，如果小于 corePoolSize 初始数量，直接创建 worker 对象执行业务，如果大于就入队列等到后续的 worker 获取处理， 如果队列满了，并且大于初始线程数量，小于 maximumPoolSize , 创建新的线程执行
- worker 在执行任务完毕的时候，会从队列中获取积累的任务执行，直到完毕，移除这个worker
- 有不符合条件的任务执行情况直接使用 不同的handler 处理
- ctl变量是最重要的属性，他包装了两个概念，工作者worker数量（workerCount） 和 线程池的状态（runState）

调度过程 需要详细看文章 
- 对于无法入队列的处理
- 创建一个任务
- 调用execute执行任务， 创建worker ，启动worker， 并在最后持续消耗队列中的任务


## 文件处理/网络

###### NIO & JAVA 


内存映射文件

JAVA处理大文件，一般用`BufferedReader`,`BufferedInputStream`这类带缓冲的IO类，不过如果文件超大的话，更快的方式是采用`MappedByteBuffer`。

`MappedByteBuffer` 是NIO引入的文件内存映射方案，读写性能极高。NIO最主要的就是实现了对异步操作的支持。其中一种通过把一个套接字通道(SocketChannel)注册到一个选择器(Selector)中,不时调用后者的选择(select)方法就能返回满足的选择键(SelectionKey),键中包含了SOCKET事件信息。这就是select模型。

SocketChannel的读写是通过一个类叫ByteBuffer来操作的.这个类本身的设计是不错的,比直接操作byte[]方便多了. 

ByteBuffer有两种模式:直接/间接.

间接模式最典型(也只有这么一种)的就是HeapByteBuffer,即操作堆内存 (byte[]).但是内存毕竟有限,如果我要发送一个1G的文件怎么办?不可能真的去分配1G的内存.

这时就必须使用”直接”模式,即 MappedByteBuffer,文件映射.

先中断一下,谈谈操作系统的内存管理.一般操作系统的内存分两部分:物理内存;虚拟内存.虚拟内存一般使用的是页面映像文件,即硬盘中的某个(某些)特殊的文件.操作系统负责页面文件内容的读写,这个过程叫”页面中断/切换”. 

MappedByteBuffer也是类似的,你可以把整个文件(不管文件有多大)看成是一个ByteBuffer.MappedByteBuffer 只是一种特殊的ByteBuffer，即是ByteBuffer的子类。 MappedByteBuffer 将文件直接映射到内存（这里的内存指的是虚拟内存，并不是物理内存）。通常，可以映射整个文件，如果文件比较大的话可以分段进行映射，只要指定文件的那个部分就可以。


###### IO包和NIO包中的内容

IO包和NIO包的内容相对来说不是很多，首先NIO模型要熟悉，特别是其中的selector一定要非常清楚它的职责和实现原理。其实NIO的核心是IO线程池，一定要记住这个关键点。有的时候，面试官可能也会问你IO包的设计模式（装饰器模式），为什么要这样设计？

抽取几个重要的面试点:

1、Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 

Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。

此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 

Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。

但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

2、[面试题:关于一些nio的问题资料](http://www.bijishequ.com/detail/403272?p=)



###### IO 

InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。 继承自InputStream 的流都是向程序中输入数据的，且数据单位为字节（8bit）；



## 反射

###### [Java JDK 动态代理使用及实现原理分析](http://blog.jobbole.com/104433/)

Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：

(1): `Interface InvocationHandler`：该接口中仅定义了一个方法: `publicobject invoke(Object obj,Method method, Object[] args)`
(2): `Proxy`：该类即为动态代理类
- `protected Proxy(InvocationHandler h)`：构造函数，用于给内部的h赋值。
- `static Class getProxyClass (ClassLoaderloader, Class[] interfaces)`：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。
- `static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)`：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)

**因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了`InvocationHandlerImpl`(构造入参是被代理类)的invoke(调用被代理类的方法，然后增强)方法。**

原理？其实就是装饰者模式，通过反射调用 被代理类的方法。



###### 动态代理的几种方式

- JDK实现动态代理需要实现类通过接口定义业务方法
- CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，

都是在子类、或者代理类 中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。


## 其他知识点


###### 异常的处理
- 直接抛出，代码该方法到此为止，不再运行下去
- 捕获处理，试图恢复正常状态，或者进行简单处理然后抛出

###### 异常链：捕获一个异常后，抛出另一个异常，但是想把第一个异常的原始信息保存下来

Throwable的子类在构造器中可以接受一个 cause对象作为参数。只有三种基本的异常类提供了cause(Throwable)参数，他们是 Error / Exception / RuntimeException 


```
java.lang.Throwable
	- java.lang.Exception
		- java.lang.RuntimeException 
	- java.lang.Error 
```

###### RuntimeException

```
if (t == null){
	throw new NullPointerException()
}
```

如果程序每个地方都要判断，代码会很难维护，其实Java会对NULL自动抛出NullPointerException异常，所以不需要额外声明，也被称为 `不受检查异常`

不知道怎么处理异常，但是又不想吞掉，可以将 `受检查异常`信息封装在 `RuntimeException` 中。


###### [深入理解Java基本数据类型](http://youdang.github.io/2017/04/17/inside-java-primitives/)


###### 浅拷贝 & 深拷贝

浅拷贝：

只对值进行拷贝，对象的拷贝直接使用引用

深拷贝：

对象的拷贝，创建一个新的对象

方法：
- 重写 clone 方法，新建对象
- 使用序列化的方式

[深拷贝 & 浅拷贝](www.paraller.com/2015/10/23/%E6%B7%B1%E6%8B%B7%E8%B4%9D-&-%E6%B5%85%E6%8B%B7%E8%B4%9D/)



