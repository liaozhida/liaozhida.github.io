---
layout:     post
title:      "面试清单(2)"
subtitle: ""
date:       2010-10-23 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-road.jpg"
tags:
    - zчастный
---
面试清单(2)-Java的开源软件的了解（实际项目中使用到的）.md


## Spring

###### spring事务

AOP 
Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的

###### 监听事件是怎么实现的？ 文件的修改 ， Application 周期事件？ 设计模式？


使用了观察者模式


[主题]: ApplicationEvent：容器事件，必须由ApplicationContext发布

[观察者]: ApplicationListener：监听器，可由容器中的任何监听器Bean担任

Spring 做的工作：   将注册的步骤，使用配置文件实现

事件源、事件和事件监听器组成。
- 事件源是ApplicationContext
- 事件必须由Java程序显式触发。

```
public class EmailEvent extends ApplicationEvent{
　　 private String address;
　　 private String text;
　　 public EmailEvent(Object source, String address, String text){
　　 super(source);
　　　　　 this.address = address;
　　　　　 this.text = text;
　　 }
　　 public EmailEvent(Object source) {
　　　　　super(source);
　　 }
　　 //......address和text的setter、getter
}
```

```
public class EmailNotifier implements ApplicationListener{
　　 public void onApplicationEvent(ApplicationEvent event) {
　　　　　if (event instanceof EmailEvent) {
　　　　　　　 EmailEvent emailEvent = (EmailEvent)event;
　　　　　　　 System.out.println("邮件地址：" + emailEvent.getAddress());
　　　　　　　 System.our.println("邮件内容：" + emailEvent.getText());
　　　　　} else {
　　　　　　　 System.our.println("容器本身事件：" + event);
　　　　　}
　　 }
}
```

```
<bean class="com.abc.EmailNotifier" />
```


```
public class SpringTest {
　　 public static void main(String args[]){
　　　　　ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
　　　　　//创建一个ApplicationEvent对象
　　　　　EmailEvent event = new EmailEvent("hello","abc@163.com","This is a test");
　　　　　//主动触发该事件
　　　　　context.publishEvent(event);
　　 }
}
```

[Spring中ApplicationContext的事件机制](https://my.oschina.net/itblog/blog/203744)



###### SpringMVC 有几个IOC容器？由什么决定
Context就是IOC容器， WebApplicationContext / ConfigurationApplicationContext

###### BeanFactory和ApplicationContext有什么区别？

BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。

BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。

从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。

提供了支持国际化的文本消息
统一的资源文件读取方式
**已在监听器中注册的bean的事件**

以下是三种较常见的 ApplicationContext 实现方式：

1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。`ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);`

2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。
`ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);`

3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。

###### Spring 框架中都用到了哪些设计模式？

Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：

- 代理模式—在AOP和remoting中被用的比较多。
- 单例模式—在spring配置文件中定义的bean默认为单例模式。
- 模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
- 工厂模式—BeanFactory用来创建对象的实例。

- 前端控制器—Spring提供了DispatcherServlet来对请求进行分发。
- 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。
- 依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。

###### [Spring AOP 实现原理与 CGLIB 应用](http://blog.jobbole.com/28791/)

广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。

假设系统中有 3 段完全相似的代码，这些代码通常会采用“复制”、“粘贴”方式来完成，通过这种“复制”、“粘贴”方式开发出来的软件如图 1 所示。：应用需要方法 1、方法 2、方法 3 彻底与深色方法分离——方法 1、方法 2、方法 3 无须直接调用深色方法，那如何解决？

我们希望有一种特殊的方法：我们只要定义该方法，无须在方法 1、方法 2、方法 3 中显式调用它，系统会“自动”执行该特殊方法。

AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP 已经成为一种非常常用的解决方案。


AspectJ 是 Java 语言的一个 AOP 实现，其主要包括两个部分：第一个部分定义了如何表达、定义 AOP 编程中的语法规范，通过这套语言规范，我们可以方便地用 AOP 来解决 Java 语言中存在的交叉关注点问题；另一个部分是工具部分，包括编译器、调试工具等。有自己的命名规范编译过程


与 AspectJ 相同的是，Spring AOP 同样需要对目标类进行增强，也就是生成新的 AOP 代理类；与 AspectJ 不同的是，Spring AOP 无需使用任何特殊命令对 Java 源代码进行编译，它采用运行时动态地、在内存中临时生成“代理类”的方式来生成 AOP 代理。


Spring 允许使用 AspectJ Annotation 用于定义方面（Aspect）、切入点（Pointcut）和增强处理（Advice），Spring 框架则可识别并根据这些 Annotation 来生成 AOP 代理。Spring 只是使用了和 AspectJ 5 一样的注解，但并没有使用 AspectJ 的编译器或者织入器（Weaver），底层依然使用的是 Spring AOP，依然是在运行时动态生成 AOP 代理，并不依赖于 AspectJ 的编译器或者织入器。



## SpringSecurity

###### 用户登录

过滤器 - Manager -> provider -> userService -> loaddb -> new Authentication -> securityContext -> hanlder


###### 页面过滤器

拦截器 -> SecurityContext -> Authentication -> AcessDecisionManager -> roleVoter -> AuthenticationVoter -> filterChain


## Solr和Lucene，中文分词技术

###### solr理解

基于lucene jar包的一个web程序

反向索引 结构化数据、非结构化数据 顺序扫描法 grep

创建索引：分词、语言处理组件、索引组件（排序）

查找索引：查询语句的语法分析、语言处理分析(语法树)、相关性排序链表合并 、权重、分值排序返回


## Spring Cloud

###### spring cloud 调用链追踪

Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可


[Spring Cloud入门教程(七)：分布式链路跟踪(Sleuth)](https://www.jianshu.com/p/c3d191663279)


## SpringBoot
 
Springboot 的实现原理 
@Condition
pom 传递依赖
类路径

为什么Springboot能更快的启动
- 减少无效的jar包， 减少过多类初始化的过程

Springboot的好处
- 完善的监控
- 减少文件配置


###### quartz

利用数据库锁的方式来实现集群环境下进行并发控制

###### feign

对 RequestTemplate  HttpURLConnnection 进行封装
简化HTTP调用,提供Http的扩展功能，编解码 压缩等； 依赖包中包含了 ribbon hystrix

[Spring Cloud入门教程(三)：声明式服务调用(Feign)](https://www.jianshu.com/p/a0d50385e598)


###### web 容器

为什么需要额外的web容器

对servlet生命周期进行管理，socket处理

###### ribbon

提供更丰富的策略

[Spring Cloud入门教程(二)：客户端负载均衡(Ribbon)](https://www.jianshu.com/p/df9393755a05)


## hystrix

解决分布式系统的什么问题：
- 故障传递，没有线程池的情况
- 资源消耗，没有熔断器的情况

如何解决：
- Hystrix 使用 HystrixCommand 命令模式来封装 依赖的逻辑调用，在强制授权下，每一个命令分别使用单独的线程/信号执行
- 可以设置调用第三方接口的超时时间，出现超时情况，直接返回开发者自己实现的 fallback 逻辑
- 提供了熔断组件，可以手动和自动调用，在一段时间内（10 seconds）停止当前的依赖系统调用，当超过了设置的错误次数 threshold 的 50%，会自动触发。
- 设置了独立线程池的依赖系统，当线程池没有空闲线程的情况下，对请求直接拒绝处理，在设置的时间内快速失败


线程池：

ConcurrentHashMap 保存每个 commandkey 单独的线程池

线程隔离 , 每个 commandkey ThreadPoolKey 有各自的线程池 
信号隔离: 轻量，缓存场景


熔断器：

mianshi： HealthCountsStream ，内部是一个concurrentMap<commandkey,HealthCountsStream> 底层是long数组的Bucket数据结构，index 为事件类型枚举对应的索引（ordinal），值为对应事件的个数
在给定十秒 10个bucket的情况下，每个bucket记录每秒的请求状态，熔断器通过他来获取健康状态决定下一步的行为

HystrixCircuitBreakerImpl

markSuccess： 关闭并重置
allowSingleTest： 尝试请求一次


父抽象类：BucketedCounterStream -> BucketedRollingCounterStream -> HealthCountsStream

- 最顶层的 BucketedCounterStream 抽象类提供了基本的桶计数器实现，按配置的时间间隔将所有事件聚合成桶；
- BucketedRollingCounterStream 抽象类在其基础上实现滑动窗口，并聚合成指标数据；
- 而最底下一层的类则是各种具体的实现，比如 HealthCountsStream 最终会聚合成健康检查数据（HystrixCommandMetrics.HealthCounts，统计调用成功和失败的计数），供 HystrixCircuitBreaker 使用。

BucketedCounterStream 抽象类提供了基本的桶计数器实现。
用户在使用 Hystrix 的时候一般都要配两个值： timeInMilliseconds 和 numBuckets ，前者代表滑动窗口的长度（时间间隔），后者代表滑动窗口中桶的个数，那么每个桶对应的窗口长度就是 bucketSizeInMs = timeInMilliseconds / numBuckets（记为一个单元窗口周期）。
BucketedCounterStream 每隔一个单元窗口周期（bucketSizeInMs）就把这段时间内的所有调用事件聚合到一个桶内。

每个熔断器默认维护10个bucket,每秒一个bucket,每个bucket记录成功,失败,超时,拒绝的状态
HealthCountsStream 类会返回健康指标决定下一步的行为

关键方法：

HealthCountsStream 对应的三个类型参数分别为：

Event: HystrixCommandCompletion，代表命令执行完成。可以从中获取执行结果，并从中提取所有产生的事件（HystrixEventType）
Bucket: 桶的类型为 long[]，里面统计了各种事件的个数。其中 index 为事件类型枚举对应的索引（ordinal），值为对应事件的个数
Output: HystrixCommandMetrics.HealthCounts，里面统计了总的执行次数、失败次数以及失败百分比，供熔断器使用

超时机制

queue.get  execute 异步执行 observe()  toObservable

降级逻辑（包含command 查询缓存）  commandkey commandgroup ThreadPoolKey  Request-Cache

批量合并执行  

调用流程
- 查看请求缓存 - 熔断器 - 资源空余 - 执行结果 - 超时
- 几种情况被统计  资源、失败、超时、成功   伴随着降级操作


###### 大纲

|--- 隔离	
|	--- thread (commandkey/commandgroup/threadPoolkey)
| 	--- signal
|
|--- 熔断器 healthCount
|
|
|--- 降级 fallback
|
|
|--- 监控	dash

流程： command - cached - breaker - thread - execute (fail/succ) -> healthCount -> succ/fallback

bucket map<commandkey,bucket> ; 十秒十个bucket  ，long类型的数组 index是事件数值；元素是 计数



## redisson

[Redisson分布式锁浅析](http://tech.lede.com/2017/03/08/rd/server/Redisson/)

redisson 方法执行 lua 脚本操作， redis级别的加锁 

RLock 继承 Lock 接口，扩展了 lock接口，增加 leaseTime 参数，多久自动释放

```
if (redis.call('exists', KEYS[1]) == 0) then 
         redis.call('hset', KEYS[1], ARGV[2], 1); 
         redis.call('pexpire', KEYS[1], ARGV[1]); 
         return nil;

```


加锁的原理 :  set 集合 ； 锁名是否存在
- 不存在就创建 name {value} 值 ，设置过期时间 ， 
- 存在就原子+1 ，设置新的过期时间





```
 "if (redis.call('exists', KEYS[1]) == 0) then " +
                      "redis.call('hset', KEYS[1], ARGV[2], 1); " +
                      "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                      "return nil; " +
                  "end; " +
                  "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                      "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                      "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                      "return nil; " +
                  "end; " +
                  "return redis.call('pttl', KEYS[1]);",
```



[分布式锁服务的关键技术和常见解决方案](http://www.voidcn.com/article/p-rsctixeo-bqo.html)

###### 分布式缓存

优点： 高效 简单

缺点： 安全性无法得到保证

特性：提供超时时间 （同时也是个隐患）

问题集：

1. A持有锁，但是A崩溃了，导致资源永远被占用
2. 过期问题的核心： 释放了不属于自己的锁
A持有锁，处理超时，Server释放锁，B持有锁，出现的问题：  A处理完成之后删除了锁，把B的也删除了 / AB同时持有锁，对资源的并发操作
3. 主备切换架构带来的问题
	异步同步：时间差，Master崩溃，slaver没有完整的数据
	解决方案：同步写，主从同时写入才代表获取锁：网络延时等问题，可用性比较差

RedLock: redis提供的官网解决方案： 引入多数派决策： 多个 Redis结点 储存数据 ： 缺点： 依赖于系统时间，会造成数据不一致。
场景：
A B C
C 结点因为时间异常，提前释放了锁
C D E 获取同一个锁  
解决方案：  延迟重启。 对C结点延迟重启处理。

硬伤： 方案不能因为各种原因 影响了加锁的安全性 ； 
根源： 没有识别和恢复、学习机制（结点出现异常，能够获取最新稳定的数据）； 没有锁版本控制

**问题一**：
A持有锁 ，定时一分钟， 业务处理耗时两分钟， 如何解决？

- 无解；使用其他的锁实现机制，舍弃分布式缓存锁

[浅谈分布式锁](http://www.linkedkeeper.com/detail/blog.action?bid=1023)



###### 分布式一致性算法

Zookeeper / Chubby 

优点：强一致性 安全可用性

Chubby ：
选定Master 读写，不断的续租。 然后扩散到其他结点，过半结点响应才返回，保证其他结点能够同步数据
每个结点有四个递增的64位数，用于区分修改时序。
- 实体编号：区分时序
- 文件内容编号： 文件内容修改时自增
- 锁编号： 被获取的时候自增
- ACL编号

提供事件机制


流程： 客户端获取锁 - 成功，其他客户端订阅锁 - 从Master中获取锁ID（序列号），后端资源服务器检查锁ID

结点故障：
重新选举Master，保存了绝大部分的数据，并通过从结点学习最新数据

结点崩溃 / 死锁：
client - Master 之间通过 KeepLive 保持 session ；长时间未收到 KeepLive ，删除 client 持有的锁 - 对于同一把锁，每一次获取锁操作，都会使得锁的序列号

Chubby 拥有 CheckSequencer 机制

当Chubby发现客户端被动失去联系的时候，并不会立即释放锁，而是会在**Lock-Delay**指定的时间内阻止其它客户端获得这个锁 


Zookeeper / Chubby 差异

Chubby 读写都在Master，所以在 client 中有缓存；Zookeeper读请求可以在从节点获取

Chubby预防死锁机制： Lock-Delay / CheckSequencer 机制； Zookeeper 只有 Lock-Delay 机制

## RocketMq


## guava （常用的组件包，不属于开源软件）



###### eureka 

- Eureka Client是一个Java客户端，用于简化与Eureka Server的交互；
- Eureka Server提供服务发现的能力，各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如网络信息），Eureka Server会存储该服务的信息；
- 微服务启动后，会周期性地向Eureka Server发送心跳（默认周期为30秒）以续约自己的信息。如果Eureka Server在一定时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（默认90秒）；
- 每个Eureka Server同时也是Eureka Client，多个Eureka Server之间通过复制的方式完成服务注册表的同步；
- Eureka Client会缓存Eureka Server中的信息。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。


核心概念：
- 租约
	

[Spring Cloud源码分析（一）Eureka](http://blog.didispace.com/springcloud-sourcecode-eureka/	)





###### Maven

生命周期的细节？




