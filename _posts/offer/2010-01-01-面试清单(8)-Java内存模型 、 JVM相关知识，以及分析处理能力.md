---
layout:     post
title:      "面试清单(8)"
subtitle: ""
date:       2010-10-23 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-road.jpg"
tags:
    - zчастный
---
面试清单(8)-Java内存模型 、 JVM相关知识，以及分析处理能力.md


## JVM 


##### 使用Java代码的整个过程

```
.java --javac--> .class --类加载器--> 转换后的.class --解释器--> 可执行代码 --JIT编译器--> 机器码
```

1、类文件在加载过程中通常会被处理和修改，比如Spring框架中的代理类
2、Java .class字节码更像是中间状态；Java中的真正编译器是JIT，将可执行代码 在 运行时编译成机器码。



###### JVM的编译优化

没有涉及， 说一下我了解的

###### JIT JVM优化

确认问题， 是调优JVM还是  JVM为了性能做了哪些优化？

- 你的代码在执行的时候，JVM会收集它运行的相关数据。一旦收集到了足够的数据，证明某个方法是热点（默认是1万次调用），JIT就会介入进来，将“运行缓慢的”平台独立的的字节码转化成本地编译的，优化瘦身后的版本。
- 有些优化是显而易见的：比如简单方法内联，删除无用代码，将库函数调用替换成本地方法等。
- 分而治之； 对代码进行分类批量处理， 比如循环的  append(",")方法
- 边界条件优化： 对于非空的判断，多次执行这段代码并且一直没有进入到if语句之后，JIT编译器会认为这个检查很多可能是多余的。然后它会重新编译这个方法，把这个检查去掉
- 虚方法内联：,JIT编译器有运行时的动态数据，它可以基于这些数据进行决策。方法内联是编译器一个常见的优化，编译器将方法调用替换成实际调用的代码，以避免一次调用的开销。不过当碰到虚方法调用（动态分发）的话情况就需要点小技巧了。
```
public class Main {
	public static void perform(Song s) {
		s.sing();
	}
}

public interface Song { 
	void sing(); 
}

public class GangnamStyle implements Song {
	@Override
	public void sing() {
		System.out.println("Oppan gangnam style!");
	}
}

public class Baby implements Song {
	@Override
	public void sing() {
		System.out.println("And I was like baby, baby, baby, oh");
	}
}
```

在多次执行perform方法后，编译器会根据它收集的数据发现，95%的调用对象都是GangnamStyle实例。这样的话，JIT编译器会很乐观将虚方法的调用优化掉。也就是说，编译器会直接生成本地代码 ，对应的Java实现大概是这样的：

```
public static void perform(Song s) {
	if (s fastnativeinstanceof GangnamStyle) {
		System.out.println("Oppan gangnam style!");
	} else {
		s.sing();
	}
}
```

JIT编译器是针对一般人的编译器；它是用来优化正常写出的代码的，它会去分析日常标准写法中的一些模式。**不要刻意写代码**去帮助JIT编译器进行优化就是对它最好的帮助 ——就正常写你自己的代码就好了。


[JVM的几点性能优化](http://it.deepinmind.com/jvm/2014/03/28/jvm-performance-magic-tricks.html)


###### JVM优化


jstat：监视虚拟机运行状态信息，使用方式：
JProfiler 工具主要用于检查和跟踪系统（限于 Java 开发的）的性能。 JProfiler 可以通过时时的监控系统的内存使用情况，随时监视垃圾回收，线程运行状况等手段，从而很好的监视 JVM 运行情况及其性能。



减少Full GC:
Full GC 的成本远远高于 Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽然在大部分情况下，JVM 会尝试在 Eden 区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在 JVM 参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入年老代的情况发生

合理设置大对象：稳定大对象入老年区
尝试在年轻代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM 不得不将年轻代中的年轻对象挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入年老代，这对 GC 相当不利。基于以上原因，可以将大对象直接分配到年老代，保持年轻代对象结构的完整性，这样可以提高 GC 的效率。如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于 GC 来说会是一场灾难。原本应该用于存放
永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，在软件开发过程中，应该尽可能避免使用短命的大对象。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配。参数-XX:PetenureSizeThreshold 只对串行收集器和年轻代并行收集器有效，并行回收收集器不识别这个参数


一般情况下，年轻对象存放在年轻代，年老对象存放在年老代。为了做到这点，虚拟机为每个对象都维护一个年龄。如果对象在 Eden 区，经过一次 GC 后依然存活，则被移动到 Survivor 区中，对象年龄加 1。以后，如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象。这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold 来设置，默认值是 15。虽然-XX:MaxTenuringThreshold 的值可能是 15 或者更大，但这不意味着新对象非要达到这个年龄才能进入年老代。事实上，对象实际进入年老代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数指定的是阈值年龄的最大值。即，实际晋升年老代年龄等于动态计算所得的年龄与-XX:MaxTenuringThreshold 中较小的那个


获得一个稳定的堆大小的方法是使-Xms 和-Xmx 的大小一致，即最大堆和最小堆 (初始堆) 一样。如果这样设置，系统在运行时堆大小理论上是恒定的，稳定的堆空间可以减少 GC 的次数。因此，很多服务端应用都会将最大堆和最小堆设置为相同的数值。但是，一个不稳定的堆并非毫无用处。稳定的堆大小虽然可以减少 GC 次数，但同时也增加了每次 GC 的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，压缩堆空间，使 GC 应对一个较小的堆，可以加快单次 GC 的速度。基于这样的考虑，JVM 还提供了两个参数用于压缩和扩展堆空间。
-XX:MinHeapFreeRatio 参数用来设置堆空间最小空闲比例，默认值是 40。当堆空间的空闲内存小于这个数值时，JVM 便会扩展堆空间。
-XX:MaxHeapFreeRatio 参数用来设置堆空间最大空闲比例，默认值是 70。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。
当-Xmx 和-Xms 相等时，-XX:MinHeapFreeRatio 和-XX:MaxHeapFreeRatio 两个参数无效。




增大吞吐量提升系统性能
吞吐量优先的方案将会尽可能减少系统执行垃圾回收的总时间，故可以考虑关注系统吞吐量的并行回收收集器。在拥有高性能的计算机上，进行吞吐量优先优化，可以使用参数：
Xmx380m –Xms3800m：设置 Java 堆的最大值和初始值。一般情况下，为了避免堆内存的频繁震荡，导致系统性能下降，我们的做法是设置最大堆等于最小堆。假设这里把最小堆减少为最大堆的一半，即 1900m，那么 JVM 会尽可能在 1900MB 堆空间中运行，如果这样，发生 GC 的可能性就会比较高；
-Xss128k：减少线程栈的大小，这样可以使剩余的系统内存支持更多的线程；
-Xmn2g：设置年轻代区域大小为 2GB；
–XX:+UseParallelGC：年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能地减少 GC 时间。
–XX:ParallelGC-Threads：设置用于垃圾回收的线程数，通常情况下，可以设置和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的；
–XX:+UseParallelOldGC：设置年老代使用并行回收收集器。




为降低应用软件的垃圾回收时的停顿，首先考虑的是使用关注系统停顿的 CMS 回收器
–XX:ParallelGCThreads=20：设置 20 个线程进行垃圾回收；
–XX:+UseParNewGC：年轻代使用并行回收器；
–XX:+UseConcMarkSweepGC：年老代使用 CMS 收集器降低停顿；
–XX:+SurvivorRatio：设置 Eden 区和 Survivor 区的比例为 8:1。稍大的 Survivor 空间可以提高在年轻代回收生命周期较短的对象的可能性，如果 Survivor 不够大，一些短命的对象可能直接进入年老代，这对系统来说是不利的。
–XX:TargetSurvivorRatio=90：设置 Survivor 区的可使用率。这里设置为 90%，则允许 90%的 Survivor 空间被使用。默认值是 50%。故该设置提高了 Survivor 区的使用率。当存放的对象超过这个百分比，则对象会向年老代压缩。因此，这个选项更有助于将对象留在年轻代。
–XX:MaxTenuringThreshold：设置年轻对象晋升到年老代的年龄。默认值是 15 次，即对象经过 15 次 Minor GC 依然存活，则进入年老代。这里设置为 31，目的是让对象尽可能地保存在年轻代区域。

我们的程序里不可避免大量使用字符串处理，避免使用 String ，应大量使用 StringBuffer ，**每一个 String 对象都得独立占用内存一块区域；**
尽量少用静态变量，因为静态变量是全局的， GC 不会回收的；

[JVM 优化经验总结](https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html)

[Java 虚拟机面试题全面解析	](https://www.zybuluo.com/Yano/note/321063)




###### Java内存模型

副本变量 重排序 缓存  屏障

Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：

[深入理解Java内存模型（一）——基础](http://www.infoq.com/cn/articles/java-memory-model-1)


###### JVM的组成和执行过程

* JVM指令系统:由操作码和操作数组成
* JVM寄存器
* JVM 栈结构
* JVM 碎片回收堆
* JVM 存储区

执行过程
* 加载.class文件
* 验证 class文件
* 解析运行
* 管理并分配内存
* 执行垃圾收集


我们的项目 设置参数-XX:+UseConcMarkSweepGC 可以要求新生代使用并行收集器，老年代使用 CMS。

###### jvm什么时候回收

1、minor gc full gc
2、不同类型的收集器 阈值不一样。  CMS默认 68%  对象的大小
3、标记-清除算法产生太多的碎片空间， 为了获取连续的空间也会触发回收


###### 双亲委派机制

JVM预定义的三种类型类加载器：

启动（ Bootstrap ）类加载器：是用本地代码实现的类装入器，它负责将 <Java_Runtime_Home>/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将< 
Java_Runtime_Home >/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。

系统（System）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。
除了以上列举的三种类加载器，还有一种比较特殊的类型 — 线程上下文类加载器。

双亲委派机制描述 :某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载

委托机制的意义 — 防止内存中出现多份同样的字节码 
比如两个类A和类B都要加载System类：

如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。
如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。


能不能自己写个类叫java.lang.System？

答案：通常不可以，但可以采取另类方法达到这个需求。 
解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。

但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。


[关于Java类加载双亲委派机制的思考（附一道面试题）](http://www.cnblogs.com/lanxuezaipiao/p/4138511.html)


###### Java dump 
Java dump 中某个资源（锁对象）下有太多的线程处于等待状态，这时候我们通常需要从以下三个方面去诊断这个问题：
这个锁存在的目的是什么？有没有可能去掉这个锁或者缩小这个锁保护的范围，从而减少线程等待问题发生的几率。
有哪些线程需要用到这个锁，有没有可能改用其它更好的替代方案。
当前哪个线程正在持有这个锁，持有的时间是多长，有没有可能缩短持有的时间

###### jvm 用到的参数
-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。

###### Eden和Survivor的比例分配等

- young generation有eden、2个survivor 区域组成。
- 其中一个survivor区域一直是空的，是eden区域和另一个survivor区域在下一次copy collection后活着的object的目的地。object在survivo区域被复制直到转移到tenured区。


Eden 区和 Survivor 区的比例为 8:1。稍大的 Survivor 空间可以提高在年轻代回收生命周期较短的对象的可能性，如果 Survivor 不够大，一些短命的对象可能直接进入年老代，这对系统来说是不利的。


## 内存模型

###### 内存栅栏

[内存屏障](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)