单元测试.md


---
layout:     post
title:      "单元测试"
date:       2018-09-21 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 代码质量
    - 测试
---

单元测试思考.md


## 单元测试的几个特性

1. 【强制】好的单元测试必须遵守AIR原则。 说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。  A：Automatic（自动化）  I：Independent（独立性）  


## 术语

SUT：System Under Test或Software Under Test的簡寫，代表待測程式。如果是單元測試，SUT就是一個function或method。
DOC：依赖组件

- 对于网络的连接
- 数据库连接
单元测试肯定是不能与实际数据库连接的，无论是本地开发数据库或者beta。所有对数据库操作的单元测试都需要是in memory。所以，你需要利用Dependency Injection的技术来提供一个in-memory database，只用于单元测试。根据题主具体使用的framework，可能有不同的方法。


代码的交付需要
- 单元测试
- 集成测试
数据库访问



---

单测依赖数据库里已有的数据，肯定是不对的。之前时间比较充裕的时候，会把用例中依赖的数据全部插入到库里，进行测试，再通过数据库事务回滚掉。但如果没有这么做也可以理解，因为数据库里的数据都是有关联的，构造测试数据不是构造一两条记录那么简单，在时间不充裕的情况下，就会直接使用库里已经有的数据了。

按 《持续交付：发布可靠软件的系统方法》 里的说法，单元测试甚至不应该依赖数据库：因为访问数据库相对而言还是比较慢的。如果单测太慢，大家就不愿意等待单测通过才 push 代码，进而会影响到持续集成。

如果待测试的代码需要依赖外部系统，那上面的问题就更明显了：外部系统的访问比数据库更慢，而且因为是外部系统，不太可能因为单元测试就去外部系统上构造数据，回滚更是无从谈起。

由此看来，最好还是在单元测试中仅测试待测代码的逻辑，mock 这段代码的外部依赖。 

---




## 附录

#### 引入的包

```
<dependency>
	<groupId>org.mockito</groupId>
	<artifactId>mockito-core</artifactId>
	<version>2.21.0</version>
</dependency>
```

```
<dependency>
	<groupId>org.powermock</groupId>
	<artifactId>powermock-module-junit4</artifactId>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>org.powermock</groupId>
	<artifactId>powermock-api-mockito2</artifactId>
	<scope>test</scope>
</dependency>
```






```
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
```

#### 类头部

集成测试
```
@RunWith(PandoraBootRunner.class)
@DelegateTo(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = Application.class)
@Component
```

web 结构的项目
```
@RunWith(PandoraBootRunner.class)
@DelegateTo(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebxContextLoader.class)
@WebAppConfiguration
```


单元测试
```
@RunWith(PandoraBootRunner.class)
@DelegateTo(MockitoJUnitRunner.class)
```


---

fund-paycore的单元测试 Base类了解一下





---


```
//PowerMockito.suppress(PowerMockito.method(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal",Long.class,BigDecimal.class));
IcbcNraBizServiceImpl spy = spy(new IcbcNraBizServiceImpl());
when(spy, method(IcbcNraBizService.class, "createNraUsdTransfer_internal")).withNoArguments().thenReturn("Good Morning %s %s");
PowerMockito.doNothing().when(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal",Long.class,BigDecimal.class);
```

PowerMockito.suppress(PowerMockito.method(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal"));




私有方法的测试：
场景：

```
class Demo{
    
    /*转账*/
    public void transfetAmount(){
        this.getBankInfo()
    }

    /*获取银行渠道信息*/
    private void getBankInfo(){
        ...
    }
}
```

这个场景中， getBankInfo 是一个私有方法，已经在线上经过长时间的验证，默认是没有问题的，对 transfetAmount 方法的单元测试，不需要再引入 `getBankInfo`的测试，简化测试的复杂度，可以对 私有方法 进行Mock

```
@RunWith(PowerMockRunner.class)
@PrepareForTest({ Demo.class })
public class DemoTest {

    @Autowried
    private Demo demo;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // 写法1
        PowerMockito.suppress(PowerMockito.method(Demo.class,"getBankInfo"));
        //
        PowerMockito.doNothing().when(IcbcNraBizServiceImpl.class,"createNraUsdTransfer_internal");
    }

    @Test
    public void test_01() {
        try {
            demo.transfetAmount();
        }catch (Exception e){
            Assert.fail();
        }
    }
}
```

几个点
- 被Mock的类不要使用接口类，你测试的是类的实现逻辑是否正确，不是接口是否优雅；而且会提示你找不到方法抛出异常。
- 


---



```
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.8.9</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4-rule</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito2</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-classloading-xstream</artifactId>
    <version>1.7.3</version>
    <scope>test</scope>
</dependency>
```


---


//通过PowerMock创建一个虚拟对象
InterfaceToMock mock = Powermockito.mock(InterfaceToMock.class)
//value为你想要让这个method返回的值
Powermockito.when(mock.method(Params…)).thenReturn(valueToReturn)
//如果这个方法返回值为空，则上面的写法会报错,可采用下面的写法
Powermockito.when(mock, “methodName”, Object… params).thenReturn(valueToReturn)
// 也可以采用下面的写法，和上面的一样的效果
Powermockito.doReturn(valueToReturn).when(mock, “methodName”, Object… params)
//这样写也行，适合返回值为void的方法
Powermockito.doReturn(valueToReturn).when(mock).methodName(Object… params)
//你也可以让方法抛异常
Powermockito.when(mock.method(Params..)).thenThrow(new OMSException(“oms”))
//你可以让方法每一次返回的结果都不一样,下面的例子第一次正常返回，第二次调用抛异常
Powermockito.when(mock.method(Params..)).thenReturn(valueToReturn).thenThrow(new OMSException(“some Exception”))
//如果方法返回值为void,不能用thenReturn,要用doThing()
Powermockito.doNothing().when(mock.method(Params…))


PowerMockito.when(vasWithdrawFacade,"queryAmountByCondition", any()).thenReturn(response);
when(vasWithdrawFacade.queryAmountByCondition(any())).thenReturn(response);



---


when(mock.someMethod("some arg"))  
  .thenThrow(new RuntimeException())  
  .thenReturn("foo");  
  
//First call: throws runtime exception:  
mock.someMethod("some arg");  
  
//Second call: prints "foo"  
System.out.println(mock.someMethod("some arg"));  
  
//Any consecutive call: prints "foo" as well (last stubbing wins).   
System.out.println(mock.someMethod("some arg"));  


when(mock.someMethod("some arg"))  
  .thenReturn("one", "two", "three");  




多次调用

---

when(mock.someMethod(anyString())).thenAnswer(new Answer() {  
    Object answer(InvocationOnMock invocation) {  
        Object[] args = invocation.getArguments();  
        Object mock = invocation.getMock();  
        return "called with arguments: " + args;  
    }  
});  
  
//Following prints "called with arguments: foo"  
System.out.println(mock.someMethod("foo"));  


--- 

8. 在真实的对象上进行spy

 

 


spy的意思是你可以修改某个真实对象的某些方法的行为特征，而不改变他的基本行为特征，这种策略的使用跟AOP有点类似。下面举一个例子来说明：

 

Java代码  收藏代码
List list = new LinkedList();  
List spy = spy(list);  
  
//optionally, you can stub out some methods:  
when(spy.size()).thenReturn(100);  
   
//using the spy calls <b>real</b> methods  
spy.add("one");  
spy.add("two");  
   
//prints "one" - the first element of a list  
System.out.println(spy.get(0));  
   
//size() method was stubbed - 100 is printed  
System.out.println(spy.size());  
   
//optionally, you can verify  
verify(spy).add("one");  
verify(spy).add("two");  
 
可以看到spy保留了list的大部分功能，只是将它的size方法改写了。不过spy在使用的时候有很多地方需要注意，一不小心就会导致问题，所以不到万不得已还是不要用spy。下面介绍两个spy的陷阱：



【1】有时我们无法使用when的方式来spy，此时我们就需要使用doReturn|Answer|Throw() 等方式来进行spy了：

 

Java代码  收藏代码
List list = new LinkedList();  
List spy = spy(list);  
  
//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)  
when(spy.get(0)).thenReturn("foo");  
  
//You have to use doReturn() for stubbing  
doReturn("foo").when(spy).get(0);  
 比如我们使用when的时候实际已经调用了get(0)方法，这个时候将直接抛出异常，所以此时应该使用doReturn来进行spy    

---



【2】spy实际上是对对象做了一个拷贝，就像上面的，如果我们直接看list这个对象，它实际上只执行了这样一句话List list = new LinkedList();


---

7. 使用 doThrow()|doAnswer()|doNothing()|doReturn() 来 stub void方法

 


void方法也需要stub？呵呵，实际生活中我们应该只会用到doThrow来模拟这个void方法出错的情况吧，anyway，mockito提供了四个方法，发挥你的想象力吧:-)

Java代码  收藏代码
doThrow(new RuntimeException()).when(mockedList).clear();  
  
//following throws RuntimeException:  
mockedList.clear();  
  参见网页例子12。



---


## 常见异常

java.lang.NoSuchMethodError: org.mockito.internal.handler.MockHandlerFactory.createMockHandler(Lorg/mockito/mock/MockCreationSettings;)Lorg/mockito/internal/InternalMockHandler;

```
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4</artifactId>
    <version>2.0.0-beta.5</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito2</artifactId>
    <version>2.0.0-beta.5</version>
    <scope>test</scope>
</dependency>
```



Extension API internal error: org.powermock.api.extension.reporter.MockingFrameworkReporterFactoryImpl
```
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito-common</artifactId>     
    <version>1.6.5</version>
</dependency>
```


javassist 包冲突问题

把不需要的版本排除掉即可，推荐版本
```
<dependency>
  <groupId>org.javassist</groupId>
  <artifactId>javassist</artifactId>
  <version>3.21.0-GA</version>
</dependency>
```



## 参考链接

[单元测试框架PowerMock教程](https://www.ezlippi.com/blog/2017/08/powermock-introduction.html)

遗留系统：
[Mockito And Private Methods](https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods)

[使用Mockito进行单元测试【2】—— stub 和 高级特性](http://qiuguo0205.iteye.com/blog/1456528)

[Android单元测试(三)：PowerMock框架的使用](https://juejin.im/entry/5a10fb786fb9a04522071756)

[TestNG使用介绍](https://www.jianshu.com/p/74816a200221)

[Mockito and Power Mockito – Cheatsheet](https://raseshmori.wordpress.com/2015/01/07/mockito-and-power-mockito-cheatsheet/)

[JUnit Testing using Mockito and PowerMock](https://blog.codecentric.de/en/2016/03/junit-testing-using-mockito-powermock/) 