# Java并发编程实战.md


## 简介

### 进程出现的原因

##### 资源利用率
程序在等待操作执行完成的空档，运行另一个程序 提高资源利用率。

##### 公平性
用户对于计算机的使用权，通过粗粒度的时间分片 使得用户和程序共享资源程序。

##### 便利、效率性
一个任务分解多个子任务，必要时通信共同完成任务。

##### 异步事件的简单处理
对于单线程而言，如果要高效处理多个操作，必须使用非阻塞IO，复杂且易错，如果能够为每个请求分配线程将降低开发的难度

线程允许在同一个进程中同时存在多个程序控制流，线程会共享进程中的资源；每个线程有各自的 程序计数器、栈、局部变量。同一个进程中的多个线程也可以被同时调度到多个CPU上运行。
 

### 多线程的风险

##### 安全性
对共享的可变的变量进行无法预测顺序的操作，将会造成与预期不一致的结果。

##### 活跃性
某个操作无法继续进行下去：A线程占有资源长时间不释放,导致B线程无法继续操作

##### 额外的性能开销:

- 线程调度器,频繁的上线文切换
- 线程共享数据/使用同步机制：抑制编译器的优化、缓存失效、共享内存总线的同步流量
	 


## 线程安全性

### 核心知识点

- 编写线程安全代码的核心在于:对状态访问操作进行管理
- 特别是对`共享` `可变的`状态进行管理
- 状态可以是数据,也可以是其他依赖的对象(比如HashMap自身或者Map.Entry对象)
- 存在多个线程访问,多个线程修改,`必须使用同步`



## 同步包括
- Synchronzied
- Lock
- volatile
- 原子变量

## 如何保证状态访问操作的安全
- 线程间不共享变量
- 将变量修改为不可变
- 访问变量时正确的同步

## 线程安全类的定义: 多个线程访问某个类时,类始终表现出正确的行为

## 竞态条件
- 定义:由于不恰当的执行顺序,而出现不正确的结果
- 如何避免:在某个线程修改变量时,阻止其他变量使用这个变量,只能在A操作完成之前或者之后,**读取和修改**状态

## 如何保证线程安全
- 对象中无状态
- 确保原子性,避免多个线程在同一时刻访问同一个状态.在单个原子操作中更新所有相关的状态变量(以下方式根据情况配合使用)
	- 使用原子变量类
	- 使用内置锁Synchronzied
- 


## 内置锁Synchronzied
- 同步代码块将包括两个部分: 一个作为锁的对象引用;一个作为由这个锁保护的代码块
- 正常路径退出 和 抛出异常退出,都将释放锁
- 重入:线程获取自己持有的锁,请求会获得成功
- 通过缩小同步代码块的范围,可以在性能和同步间找到平衡
- 一种常见的加锁约定:通过将状态封装在对象内,通过同一个对象锁,对状态的读写访问都添加锁来确保安全
- 用同步来协调对一个变量的访问
	- 在访问这个变量的所有位置上都需要同步
	- 所有位置上都必须使用同一个锁
	- 不仅写入需要,读取也需要同步
- 当执行长时间计算和无法快速完成的操作,时,一定不要持有锁


## 多个原子操作组成的复合操作,仍然需要同步机制

# 对象的共享

## 内存可见性
- 定义: 当一个线程修改了一个共享变量,其他线程能够看到发生的状态变化
- 避免: 只要有数据在多个线程之间共享,就使用正确的同步
- tips: 不仅要对修改方法进行同步,读取方法也要

## 最低安全性
- 在没有同步的情况下读取变量,可能会得到一个失效值,但至少这个值是上一个线程设置的.而不是一个随机值

## 加锁与内存可见性
- 加锁的含义不仅是互斥行为,还包括内存可见性,确保所有线程都能看到共享变量的最新值

## 重排序
- 在没有同步的情况下,编译器,处理器可能会对操作的执行顺序进行调整,内存操作不一定是顺序执行的

##  valatile变量
- 变量不会被缓存在寄存器或者其他处理器不可见的地方,在读取valatile变量时总会返回最新写入的值

# 知识点
- 某些框架会自带多线程
- Java 一般都有多线程,后台GC,一个线程执行MAIN函数
- 程序状态封装性越好,越容易做到线程安全,也越容易维护
- 
-
-
-
-

# 多线程的风险
- 安全性:竞态条件
- 活跃性:A线程占有资源长时间不释放,导致B线程无法继续操作
- 性能:
	- 线程调度器,频繁的上线文切换
	- 线程共享数据/使用同步机制; 
		- 抑制编译器的优化
		- 缓存失效




# 线程安全性

## 编写线程安全代码的**核心**在于:对**状态访问操作**进行管理
- 特别是对**共享** **可变的**状态进行管理
- 状态可以是数据,也可以是其他依赖的对象(比如HashMap自身或者Map.Entry对象)

##一个对象是否**需要**线程安全的,取决于是否会被多个线程访问

##存在多个线程访问,多个线程修改,**必须使用同步**

## 同步包括
- Synchronzied
- Lock
- volatile
- 原子变量

## 如何保证状态访问操作的安全
- 线程间不共享变量
- 将变量修改为不可变
- 访问变量时正确的同步

## 线程安全类的定义: 多个线程访问某个类时,类始终表现出正确的行为

## 竞态条件
- 定义:由于不恰当的执行顺序,而出现不正确的结果
- 如何避免:在某个线程修改变量时,阻止其他变量使用这个变量,只能在A操作完成之前或者之后,**读取和修改**状态

## 如何保证线程安全
- 对象中无状态
- 确保原子性,避免多个线程在同一时刻访问同一个状态.在单个原子操作中更新所有相关的状态变量(以下方式根据情况配合使用)
	- 使用原子变量类
	- 使用内置锁Synchronzied
- 


## 内置锁Synchronzied
- 同步代码块将包括两个部分: 一个作为锁的对象引用;一个作为由这个锁保护的代码块
- 正常路径退出 和 抛出异常退出,都将释放锁
- 重入:线程获取自己持有的锁,请求会获得成功
- 通过缩小同步代码块的范围,可以在性能和同步间找到平衡
- 一种常见的加锁约定:通过将状态封装在对象内,通过同一个对象锁,对状态的读写访问都添加锁来确保安全
- 用同步来协调对一个变量的访问
	- 在访问这个变量的所有位置上都需要同步
	- 所有位置上都必须使用同一个锁
	- 不仅写入需要,读取也需要同步
- 当执行长时间计算和无法快速完成的操作,时,一定不要持有锁


## 多个原子操作组成的复合操作,仍然需要同步机制

# 对象的共享

## 内存可见性
- 定义: 当一个线程修改了一个共享变量,其他线程能够看到发生的状态变化
- 避免: 只要有数据在多个线程之间共享,就使用正确的同步
- tips: 不仅要对修改方法进行同步,读取方法也要

## 最低安全性
- 在没有同步的情况下读取变量,可能会得到一个失效值,但至少这个值是上一个线程设置的.而不是一个随机值

## 加锁与内存可见性
- 加锁的含义不仅是互斥行为,还包括内存可见性,确保所有线程都能看到共享变量的最新值

## 重排序
- 在没有同步的情况下,编译器,处理器可能会对操作的执行顺序进行调整,内存操作不一定是顺序执行的

##  valatile变量
- 变量不会被缓存在寄存器或者其他处理器不可见的地方,在读取valatile变量时总会返回最新写入的值

# 知识点
- 某些框架会自带多线程
- Java 一般都有多线程,后台GC,一个线程执行MAIN函数
- 程序状态封装性越好,越容易做到线程安全,也越容易维护
- 
-
-
-
-