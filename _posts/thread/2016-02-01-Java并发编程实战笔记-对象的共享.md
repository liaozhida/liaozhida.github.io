---
layout:     post
title:      "Java并发编程实战笔记(2)-对象的共享"
date:       2016-02-01 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-2015.jpg"
tags:
    - 并发编程
---

### 核心知识点

- 同步不仅能够保证原子性; 还能实现内存可见性: 当一个线程修改了对象状态后,其他线程能够看到发生的状态变化

- 如何让多个线程安全的访问可变状态 ?

### 可见性

##### 重排序

```
class Test{
	private static boolean visible;
	private static int number;

	static class Reader extends Thread{
		void run(){
			while(!visible){
				Thread.yield();
			}
			system.out.println(number);
		}
	}

	static void main(String[]  args){
		new Reader().start();
		number = 12;
		visible = true;
	}
}
```

Reader线程可能看到了visible的值,却没有看到number的,这种现象称为`重排序`

Jvm为了充分利用现代多核处理器,可能对操作的执行顺序进行调整

如何避免 : 只要有数据在线程之间共享,就使用正确的同步

##### Volatile

- 变量不会被缓存在寄存器或者其他处理器不可见的地方,在读取valatile变量时总会返回最新写入的值
- 变量声明为 volatile,编译器和运行时都会注意到这个变量是共享的,不会将该变量的操作与其他内存操作一起`重排序`

使用场景:

检查某个状态标记以判断是否退出循环:(因为所有线程修改对其他线程都是可见)
`
while(!asleep){
	// TODO
}
`

### 发布与逸出

##### 核心知识点

- 发布的概念: 指对象能够在当前作用域之外的代码中使用.
- 发布内部的状态会破坏封装性,会破坏线程安全
- 逸出:  某个不应该被发布的对象被发布,就成为逸出(Escape)
- 当对象在其构造函数中创建一个线程时，this引用都会被新创建的线程共享；解决方案：在构造函数中创建但不是马上启动它，而是通过一个方法来启动。

逸出常见场景1: 将对象保存在共有的静态变量.

```
public static Set<Object>  hello;

public void init(){
	hello = new HashSet<Object>()
}
```


逸出常见场景2: 非私有方法中返回一个引用.

```
class A{
	private Object obj = new Object()''

	public get Obj(){
		return this.obj;
	}
}
```


### 线程封闭

##### 核心知识点

- 避免使用同步的方式就是`不共享`数据: 如果仅在单线程内访问数据，就不需要同步。
- 线程封闭： 在数据封闭在一个线程中不共享

##### 栈封闭

定义：栈封闭？其实就是把同步变量写在局部方法中，当然就线程安全了，根本不会共享变量。线程私有。

注意事项：确保栈内对象不会逸出

##### ThreadLocal

概念：ThreadLocal 提供了get /set等访问接口或方法，这些方法为每个使用该变量的线程都保存一份独立的副本， 因此Get方法总是返回由`当前执行线程在调用set`时设置的最新值。

使用ThreadLocal，能使线程中的某个值所有改变只在该当前线程中变动，不会被其他线程操作，保证了当前线程的数据`不共享`,避免竞态条件的发生。

场景： Spring中的事务上下文(Transaction Context)，需要对当前线程进行 回滚、提交 操作，为了当前事务不会和其他线程串了，就通过将事务上下文与某个执行线程关联起来。

缺点： 耦合性会更强，并且降低代码的可重用性

### 不变性

##### 核心知识点

- 如果某个对象被创建之后就不能被改变（不变性条件是由构造函数创建的），就一定是线程安全的。
- 即使对象中所有的域都是final类型的，这个对象仍然可能是可变的， 因为final类型的域可以保存对 可变对象的引用



# 知识点
- 某些框架会自带多线程
- Java 一般都有多线程,后台GC,一个线程执行MAIN函数
- 程序状态封装性越好,越容易做到线程安全,也越容易维护
