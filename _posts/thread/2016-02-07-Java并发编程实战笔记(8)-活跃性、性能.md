---
layout:     post
title:      "Java并发编程实战笔记(8)-活跃性、性能"
date:       2016-02-05 12:00:00
author:     "zhidaliao"
header-img: "img/post-bg-2015.jpg"
tags:
    - 并发编程
    - 学习笔记
---

过度使用锁，可能会导致锁锁顺序死锁

T1持有锁A等到锁B ， T2持有锁B等待锁A，最简单的死锁形式，称为**抱死**

每个线程假想为有向图的一个节点，每条边的表示为：一个节点等待下一个节点的锁，如果在图中形成一个环路，那么就存在 **死锁**

数据库的事务场景：数据库服务器检测到一组事务出现死锁的时候，将选择一个牺牲者并放弃一个事务

JVM发生死锁的时候，只能终止并重启

锁顺序死锁：两个线程按照不同的顺序获取 **相同的锁** ； 解决方案： 必须定义锁的顺序，并在整个程序中使用这个顺序来获取锁

比如通过哈希值的大小来决定获取两个锁的顺序

极端情况下，哈希值可能一致，也会导致死锁
引入 **加时赛锁**(tie-break) ， 新增一个对象锁在最外层。已未知的顺序获取
对于队列而言： 当优先级一样的情况下，就成为 tie-break, 一般是通过谁先出现谁先入栈

协作对象之间发生死锁

场景：

Note： 在`持有锁`的情况下，调用某个外部方法，那么就需要警惕死锁





