---
layout:     post
title:      "[转]MD5(2)-破解MD5之我见"
date:       2016-05-22 12:00:00
author:     "zhida"
header-img: "img/post-bg-1.jpg"
tags:
    - 安全
---

`转载：http://blog.csdn.net/raptor/article/details/97270  对原文做了修改`

### 关于王小云破解MD5之我见

MD5是一种摘要算法，所以理论上是不可能从签名取得原文（见下面说明）。认为要从MD5的结果中取得原文才算破解，本身就是对摘要算法的误解。它通常应用于数字签名中，用于标识原文的原始性--即在签名后未作任何的修改。用不同的原文可以产生相同的签名，这也就意味着签名可能失效，就已经可以证明这种摘要算法的不安全。

王小云的发现证明了有方法可以产生碰撞，但正如GIGIX那边一位匿名兄所说，**这只是非特定碰撞，而要伪造签名则必须能产生特定碰撞。所以说MD5并未被完全攻破**，但也已经是一个重大的突破了。

首先要说的是为什么需要使用密码？因为我们通常的通信环境是不安全的。
那什么是不安全的通信环境呢？不安全至少表现在两个方面：

- 通信的内容可能被窃取；
- 二是通信的内容可能被篡改。


通常的密码使用就是为这解决这两方面的问题。
而如果有方法使某种密码的作用失效，就可以说这种密码被破解了。

常用的密码有很多种类，其中最常用的是这三种：

- 摘要算法
- 非对称密码
- 摘要

#### 对称密码

特点是：加密与解密用相同的密钥，甚至可能用相同的算法。比如从最简单的异或，到常用的DES、BLOWFISH、IDEA等。它们通常的用途是这样的：
发送方将源文（M）用密钥（K）加密：E=ENC（M，K）
然后将E通过不安全网络传给接收方，接收方用相同的密钥（K）解密：M=DEC（E，K）
只要算法足够好，并且保管好密钥（K），就可以保证这种通信是安全的，因为别人即使知道了密文（E）和算法ENC/DEC，也无法知道明文（M）。

对于这种密码来说，如果有方法可以从密文（E）和算法ENC/DEC中导到密钥（K）或明文（M），则意味这种密码被破解。比如简单异或算法就可以用统计分析法简单地破解掉。但即使是现在被认为不够安全的**DES**算法（已经有近三十年历史了），也需要有大量的明文/密文对（2的数十次方对），并需要大量的计算时间才能求得其密钥（K）。

#### 非对称密码

因为在对称密码中，通信双方需要约定一个共同的密钥（K），如果这个约定过程也不安全，就可能出现密钥的泄露，而对于对称算法来说，密钥一旦泄露，之后的通信过程也就不攻自破了。
通常的非对称密码就是所谓的公钥密码算法，比如现在最常用的**RSA**（由R. L. Rivest和A. Shamir等人基于大数的因数分解极为困难的原理而创建），或是最近更为时髦的“椭圆曲线”，因为我的数学水平太差，具体算法也说不清楚，只知道大致是这样的：
顾名思义，它所用的算法特点在于加密与解密用的密钥是不一样的。

而其中双方都不需要知道对方的私钥，这就避免了约定密钥导致的不安全。
非对称密码的算法本身又决定了用私钥加密的内容必须用公钥才能解，反之亦然，并且算法还保证仅知道公钥和密文无法导出私钥，由此决定了通信的安全。
当然，如果有方法可以从公钥导出私钥来，则这种算法即告被破解。但至少目前RSA还是安全的，因为从现在的数学理论上可以证明RSA的算法是一类NPC（NP完备）类问题，只要密钥足够长（RSA要求至少是10的100次方以上，实际使用时更要大得多），以现在最先进的计算机来算，其时间成本也是不可能达到的。

#### 摘要算法

与上面两种完全不同，前面两种密码是用于防止信息被窃取，而摘要算法的目标是用于证明原文的完整性，也就是说用于防止信息被篡改。通常也被称为：HASH算法、杂凑算法、签名算法。它的特点是：从不定长的原文中产生一个固定长度（如MD5是128位）的结果，称为“签名”（S），这个签名必须对原文非常敏感，即原文即使是有少量的变化，也会导致这个签名面目全非。比如传统的CRC或是现在要说的MD5、SHA等都是这类算法。

摘要算法的用途通常是这样的：

##### 密码验证：

如Linux或一些论坛用的方法，用户设置密码时，服务端只记录这个密码的MD5，而不记录密码本身，以后验证用户身份时，只需要将用户输入的密码再次做一下MD5后，与记录的MD5作一个比较即可验证其密码的合法性。

##### 完整性签名验证：

比如发布一个程序，为了防止别人在你的程序里插入病毒或木马，你可以在发布这个程序的同时，公开这个程序文件的MD5码，这样别人只需要在任何地方下载这个程序后做一次MD5，然后跟公开的这个MD5作一个比较就知道这个程序是否被第三方修改过。

一个安全的摘要算法在设计时必须满足两个要求：

- 寻找两个输入得到相同的输出值在计算上是不可行的，这就是我们通常所说的抗碰撞的；
- 找一个输出，能得到给定的输入在计算上是不可行的，即不可从结果推导出它的初始状态。

反之，如果某种摘要算法不能同时满足上面两个条件，则它就是不安全的。其实主要还是前一个条件，因为从理论上很容易证明后面一个条件基本上都是可以满足的：

摘要算法对任意长的原文产生定长的签名，按照香农的信息论，**当原文的长度超过一定的程度的时候，签名中就无法记录原文中的所有信息，这意味着存在着信息的丢失，所以我说理论上不可能从签名中恢复原文。**
为什么说理论上呢？就是说当这种摘要算法被完全攻破时，也就是说可以从签名恢复出任意原文，注意：是任意原文，因为**所有的摘要算法的特点就是存在着一个无穷大的碰撞原文的集合。而真正的原文只是其中一份**。对应这个无穷大的集合来说，这就是一个无穷小，便是我曾经说过的： 

可能性为零，不表示不可能。 

解释得具体一点是这样：假设原文含有信息量（I），而签名的长度有限（如MD5的128位），则它的信息量只有(i)，因为通常 i < I （除非原文非常短），所以可以这么说：I=i+i'。因为I没有限制，而i有限制，则 i' 也是一个没有限制的量。当进行摘要算法后，i' 信息就丢失了。
反过来，如果现在这种摘要算法被攻破了，可以从 i 反推回去，但因为 i' 信息已经丢失，意味着 i + I' （其中 I' 为任意信息）都可能是 I （碰撞）。但 I' 是一个无穷集合，并且 i' 属于 I'。这说明：理论上可以从 I' 中找到 i' 从而恢复出原文 I ，但是可能性为零（1/∞=0）。

但要做到前面一点就不容易了。因为**绝对无碰撞的算法不可能是一个摘要算法，而只能是一个无损压缩算法**。它必须包含原文的所有信息，也就意味着它一但被攻破，可以唯一地恢复出原文。并且**它的结果肯定是不定长的，因为它需要包含原文的所有信息，当然会根据原文的长度而变**。仅这两点就决定了，它不可能是一个好的签名算法。
最主要的一点是：摘要算法的用途决定了，它只要能找到碰撞就足以让它失效，并不需要找到原文。

以前面的两个例子来说：·
比如Linux的用户安全机制，只要得到用户密码文件（其中记录了密码的MD5），然后随便生成一个碰撞的原文（不一定要跟原密码相同），就可以用这个密码登录了。
但后面的程序发布的例子就要难得多，因为它必须能生成特定的碰撞，即在程序中插入病毒或木马后再填充一些数据使之生成与原来相同的MD5。
不过我昨天仔细想了一下，以MD5为例，要产生特定的碰撞应该还是不太可能的，因为MD5的128位信息量已经有点大了，如果要产生特定碰撞，需要填充的数据可能非常之大，导致伪造的原文比真实的原文大得多，可能达到若干个数量级的差别，这样的伪造就已经失去意义了。

我举的例子来说明一下。比如昨天我说的，假如有两个人的指纹完全相同，而且我可以很快的找出这两个人，那么，在法律角度来说，我们就不能把指纹作为一个有效证据。虽然这两个同指纹的人并没有互相冒充的意思。 

同样的，现在刻意去伪造文件并产生相同的MD5码还做不到，但是，如果可以在短时间内找到两份相同的档案，他们的MD5码相同，那么，MD5作为数字签名的“法律意义”便失去了。而数字签名是用来干吗的？就是让一个电子文档具有法律意义的。所以，我说，这个发现是动摇了数字签名的根基。
