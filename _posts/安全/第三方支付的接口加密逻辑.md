## 第三方支付

#### 第一步简单加密

目的是为了保证上传的参数信息没有被篡改，主要分成三部分

- 接口参数 : 需要和第三方对接的参数 
- 加密类型 : 使用什么类型加密，一般为MD5
- 加密密文 : 使用接口参数和第三方生成的key值(固定salt,相对于第三方就是随机salt),进行MD5加密后的密文
 
`Md5作为数字签名 H(A)=P  已知A P，在特殊情况下可以伪造A1 满足H(A1)=p`  

 
#### 生成加密的密钥Key

随机生成16位的加密密钥Key，用于对上一步的内容进行对称加密


#### 使用证书加密密钥Key

对随机生成的密钥key进行加密。防止在传输过程中被截获破解。

使用了三种加密算法：

- 摘要算法：验证原文是否被篡改
- 对称加密算法：使用密钥对原文进行加密(AES)
- 非对称加密算法：对密钥进行分发

```      
----------------------------------         ----------				-------------
   |                   |						|						  |
  入参         H(入参+分配的code)=P  		  生成随机的Key值				   第三方证书
   |		           |						|						  |
----------------------------------			---------				-------------	
			  |									|						  |				
			  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _|						  
			  					|							|
			  				AES对称加密					证书加密
			  					|							|
			  					 - - - - - - - - - - - - - - 
			  					 			  |
			  					 	     Http发送请求

```

#### 第三方的处理步骤

- 证书加密的随机数，使用私钥解密得到 Akey
- AES(AKey) = sourceCode("入参","P")
- 验证：H(sourceCode + code) = P 




## 一般的接口调用校验流程

- 请求参数按照参数名字符升序排列，如果有重复参数名，那么重复的参数再按照参数值的字符升序排列。
- 所有参数（除了sign和sign_type）按照上面的排序用&连接起来，格式是：a=v1&b=v2。
- 将上面参数组成的字符串加上安全校验码组成待签名的数据，安全校验码通过平台分配，假设安全校验码为123456789，那计算sign的原串为a=v1&b=v2123456789


**伪代码**
```
H (user=tom&pass=123&key=abc) = P
API post ("user=tom&pass=123","P")
```

key只有两方内部保存，确保传递的参数没有被第三方篡改。
