<h2 id="spring-rpc-实践---http-invoker">spring RPC 实践 - http invoker</h2>

<p>Spring支持多种不同的RPC模型，包括RMI、Hessian/Burlap以及Spring自带的Http Invoker。下面我将简单介绍一下它们之间的异同点：</p>

<ul>
  <li>RMI：不考虑网络限制时使用（PS：因为RMI使用任意端口来交互，有时无法穿越防火墙）</li>
  <li>Hessian/Burlap：考虑网络限制时，通过HTTP访问/发布基于Java的服务。Hessian是基于二进制的远程调用技术；而Burlap是基于XML的远程调用技术</li>
  <li>Spring的HttpInvoker：跟Hessian/Burlap实现的调用技术类似，但是不同的是Hessian/Burlap使用了私有的对象序列化机制，而Spring的Http Invoker则使用的是Java的序列化机制</li>
  <li>WebService :</li>
</ul>

<p>但是，不管选择哪种远程调用模型我们都会发现Spring提供了风格一致的支持。这意味着一旦理解了如何在Spring中配置和使用其中一种模型。那么当我们想要使用另外一种模型的话，将会变得非常容易</p>

<p>在所有的模型中，服务都作为Spring所管理的bean配置到我们的应用中。这是通过一个代理工厂bean实现的，这个bean能够把远程服务像本地对象一样装配到其他bean的属性中去。客户端向代理发起调用，就像代理提供了这些服务一样。代理代表客户端与远程服务进行通信，由它负责处理连接的细节并向远程服务发起调用。最后代理再返回远程服务执行完成之后的结果，至此整个调用过程完成</p>

<p>无论我们开发的是使用远程服务的代码，还是实现这些服务的代码，或者两者兼而有之。在Spring中，使用远程服务纯粹是一个配置问题。我们不需要编写任何Java代码就可以支持远程调用。我们的服务bean也不需要关心它们是否参与了一个RPC(PS：任何传递给远程调用的bean或从远程调用返回的bean可能需要实现java.io.Serializable 接口）</p>

<h3 id="服务端项目">服务端项目</h3>

<p>初始化项目，然后导入eclipse中</p>

<div class="highlighter-rouge"><pre class="highlight"><code>spring init -dredis,web rpc-demo
</code></pre>
</div>

<p>定义service接口和实现类</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface ITicketService {
	
	public Message&lt;String&gt; test();

}


@Service
public class TicketService implements ITicketService{

	@Override
	public Message&lt;String&gt; test() {
		
		int counter = Ticket.find.where().findRowCount();		
		return new Message&lt;String&gt;("hello world" + counter);

	}
}
</code></pre>
</div>

<p>使用@Bean发布远程服务</p>
<div class="highlighter-rouge"><pre class="highlight"><code>@SpringBootApplication
public class Application {
	
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

	/**
	 * 发布产品类
	 * 
	 * @param myServiceImpl
	 * @return
	 */
	@Bean(name = "/ticket.service")
	public HttpInvokerServiceExporter myHttpInvokerServiceExporter(ITicketService service) {
	    HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
	    exporter.setServiceInterface(ITicketService.class);
	    exporter.setService(service);
	    return exporter;
	}
	
	/**
	 * 发布产品的缓存类
	 * 
	 * @param productRedisServiceImp
	 * @return
	 */
	@Bean(name = "/ticket.redisService")
	public HttpInvokerServiceExporter myHttpInvokerRedisServiceExporter(ITicketRedisService service) {
	    HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
	    exporter.setServiceInterface(ITicketRedisService.class);
	    exporter.setService(service);
	    return exporter;
	}
}

</code></pre>
</div>

<h4 id="多环境profie">多环境Profie</h4>

<ul>
  <li>使用常规的maven环境配置</li>
  <li>使用 application-{env} , 可以查看配置属性 附录</li>
</ul>

<h4 id="打包">打包</h4>

<ul>
  <li>使用常规的maven打包</li>
</ul>

<h4 id="异常处理">异常处理</h4>

<h4 id="解决超时重复操作的问题">解决<strong>超时</strong>重复操作的问题</h4>

<ul>
  <li>不使用第三方架构的处理方式： 客户端调用时生成一个随机字符串key，服务端接收key之后保存在内存中，以乐观锁的形式避免多次重复调用。</li>
</ul>

<h4 id="日志">日志</h4>

<p>在类目录下增加logback.xml ,增加相应的jar包即可</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;!-- 日志记录 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
	&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
	&lt;version&gt;${logback.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;
	&lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;
	&lt;version&gt;0.1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;
	&lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;
	&lt;version&gt;4.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
	&lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
	&lt;version&gt;1.7.12&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
	&lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;
	&lt;version&gt;1.7.12&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
	&lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;
	&lt;version&gt;1.7.12&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.aspectj&lt;/groupId&gt;
	&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
	&lt;version&gt;1.8.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</div>

<h3 id="测试客户端">测试客户端</h3>

