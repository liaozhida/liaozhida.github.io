<h2 id="第三方支付">第三方支付</h2>

<h4 id="第一步简单加密">第一步简单加密</h4>

<p>目的是为了保证上传的参数信息没有被篡改，主要分成三部分</p>

<ul>
  <li>接口参数 : 需要和第三方对接的参数</li>
  <li>加密类型 : 使用什么类型加密，一般为MD5</li>
  <li>加密密文 : 使用接口参数和第三方生成的key值(固定salt,相对于第三方就是随机salt),进行MD5加密后的密文</li>
</ul>

<p><code class="highlighter-rouge">Md5作为数字签名 H(A)=P  已知A P，在特殊情况下可以伪造A1 满足H(A1)=p</code></p>

<h4 id="生成加密的密钥key">生成加密的密钥Key</h4>

<p>随机生成16位的加密密钥Key，用于对上一步的内容进行对称加密</p>

<h4 id="使用证书加密密钥key">使用证书加密密钥Key</h4>

<p>对随机生成的密钥key进行加密。防止在传输过程中被截获破解。</p>

<p>使用了三种加密算法：</p>

<ul>
  <li>摘要算法：验证原文是否被篡改</li>
  <li>对称加密算法：使用密钥对原文进行加密(AES)</li>
  <li>非对称加密算法：对密钥进行分发</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>----------------------------------         ----------				-------------
   |                   |						|						  |
  入参         H(入参+分配的code)=P  		  生成随机的Key值				   第三方证书
   |		           |						|						  |
----------------------------------			---------				-------------	
			  |									|						  |				
			  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ _|						  
			  					|							|
			  				AES对称加密					证书加密
			  					|							|
			  					 - - - - - - - - - - - - - - 
			  					 			  |
			  					 	     Http发送请求

</code></pre>
</div>

<h4 id="第三方的处理步骤">第三方的处理步骤</h4>

<ul>
  <li>证书加密的随机数，使用私钥解密得到 Akey</li>
  <li>AES(AKey) = sourceCode(“入参”,”P”)</li>
  <li>验证：H(sourceCode + code) = P</li>
</ul>

<h2 id="一般的接口调用校验流程">一般的接口调用校验流程</h2>

<ul>
  <li>请求参数按照参数名字符升序排列，如果有重复参数名，那么重复的参数再按照参数值的字符升序排列。</li>
  <li>所有参数（除了sign和sign_type）按照上面的排序用&amp;连接起来，格式是：a=v1&amp;b=v2。</li>
  <li>将上面参数组成的字符串加上安全校验码组成待签名的数据，安全校验码通过平台分配，假设安全校验码为123456789，那计算sign的原串为a=v1&amp;b=v2123456789</li>
</ul>

<p><strong>伪代码</strong></p>
<div class="highlighter-rouge"><pre class="highlight"><code>H (user=tom&amp;pass=123&amp;key=abc) = P
API post ("user=tom&amp;pass=123","P")
</code></pre>
</div>

<p>key只有两方内部保存，确保传递的参数没有被第三方篡改。</p>
